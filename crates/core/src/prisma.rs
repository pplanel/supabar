// Code generated by Prisma Client Rust. DO NOT EDIT.

#![allow(warnings, unused)]
use prisma_client_rust::{
    bigdecimal::{self, FromPrimitive},
    chrono,
    datamodel::parse_configuration,
    operator::Operator,
    prisma_models::{InternalDataModelBuilder, PrismaValue},
    query::{QueryContext, Result as QueryResult},
    query_core::{
        executor, schema_builder, BuildMode, CoreError, InterpreterError, QueryExecutor,
        QueryGraphBuilderError, QuerySchema, QueryValue, Selection,
    },
    serde_json, transform_equals, Args, BatchResult, Direction, FindManyArgs,
    FindManySelectionArgs, SerializedWhere, SerializedWhereValue,
};
pub use prisma_client_rust::{query::Error as QueryError, NewClientError};
use serde::{Deserialize, Serialize};
use std::fmt;
use std::ops::Deref;
use std::path::Path;
use std::sync::Arc;
static DATAMODEL_STR : & 'static str = "datasource db {\n  provider = \"sqlite\"\n  url      = \"file:dev.db\"\n}\n\ngenerator client {\n  provider = \"cargo run --bin prisma --\"\n  output   = \"./src/prisma.rs\"\n}\n\nmodel Migration {\n  id            Int      @id @default(autoincrement())\n  name          String\n  checksum      String   @unique\n  steps_applied Int      @default(0)\n  applied_at    DateTime @default(now())\n\n  @@map(\"_migrations\")\n}\n\nmodel User {\n  id           Int      @id @default(autoincrement())\n  username     String @unique\n  index_dir    String\n  data_dir     String\n  hostname     String?\n  platform     Int      @default(0)\n  date_created DateTime @default(now())\n\n  jobs Job[]\n\n  @@map(\"users\")\n}\n\nmodel File {\n  id                 Int      @id @default(autoincrement())\n  // content addressable storage id - sha256\n  // this does not need to be unique, as incoming replicas will always ignore if at least one exists\n  cas_id             String   @unique\n  // full byte contents digested into sha256 checksum\n  integrity_checksum String?  @unique\n  // basic metadata\n  kind               Int      @default(0)\n  size_in_bytes      String\n  key_id             Int?\n  // handy ways to mark a file\n  hidden             Boolean  @default(false)\n  favorite           Boolean  @default(false)\n  important          Boolean  @default(false)\n  // if we have generated preview media for this file\n  has_thumbnail      Boolean  @default(false)\n  has_thumbstrip     Boolean  @default(false)\n  has_video_preview  Boolean  @default(false)\n  // integration with ipfs\n  ipfs_id            String?\n  // plain text comment\n  comment            String?\n  // the original known creation date of this file\n  date_created       DateTime @default(now())\n  // the last time this file was modified\n  date_modified      DateTime @default(now())\n  // when this file was first indexed\n  date_indexed       DateTime @default(now())\n\n  tags       TagOnFile[]\n  media_data MediaData?\n\n  @@map(\"files\")\n}\n\nmodel MediaData {\n  id                      Int     @id\n  pixel_width             Int?\n  pixel_height            Int?\n  longitude               Float?\n  latitude                Float?\n  fps                     Int?\n  capture_device_make     String? // eg: \"Apple\"\n  capture_device_model    String? // eg: \"iPhone 12\"\n  capture_device_software String? // eg: \"12.1.1\"\n  duration_seconds        Int?\n  codecs                  String? // eg: \"h264,acc\"\n  streams                 Int?\n\n  // change this relation to File after testing\n  files File? @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)\n\n  @@map(\"media_data\")\n}\n\nmodel Tag {\n  id              Int      @id @default(autoincrement())\n  pub_id          String   @unique\n  name            String?\n  total_files     Int?     @default(0)\n  redundancy_goal Int?     @default(1)\n  date_created    DateTime @default(now())\n  date_modified   DateTime @default(now())\n\n  tag_files TagOnFile[]\n  @@map(\"tags\")\n}\n\nmodel TagOnFile {\n  date_created DateTime @default(now())\n\n  tag_id Int\n  tag    Tag @relation(fields: [tag_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n  file_id Int\n  file    File @relation(fields: [file_id], references: [id], onDelete: NoAction, onUpdate: NoAction)\n\n  @@id([tag_id, file_id])\n  @@map(\"tags_on_files\")\n}\n\nmodel Job {\n  id      String @id\n  name    String\n  node_id Int\n  action  Int\n  status  Int    @default(0)\n\n  task_count           Int      @default(1)\n  completed_task_count Int      @default(0)\n  date_created         DateTime @default(now())\n  date_modified        DateTime @default(now())\n  seconds_elapsed      Int      @default(0)\n\n  User   User? @relation(fields: [userId], references: [id])\n  userId Int?\n  @@map(\"jobs\")\n}\n" ;
pub struct PrismaClient {
    executor: Box<dyn QueryExecutor + Send + Sync + 'static>,
    query_schema: Arc<QuerySchema>,
}
impl fmt::Debug for PrismaClient {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PrismaClient").finish()
    }
}
pub async fn new_client() -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let url = if let Some(url) = source.load_shadow_database_url()? {
        url
    } else {
        source.load_url(|key| std::env::var(key).ok())?
    };
    let url = if url.starts_with("file:") {
        let path = url.split(":").nth(1).unwrap();
        if Path::new("./schema.prisma").exists() {
            url
        } else if Path::new("./prisma/schema.prisma").exists() {
            format!("file:./prisma/{}", path)
        } else {
            url
        }
    } else {
        url
    };
    new_client_with_url(&url).await
}
pub async fn new_client_with_url(url: &str) -> Result<PrismaClient, NewClientError> {
    let config = parse_configuration(DATAMODEL_STR)?.subject;
    let source = config
        .datasources
        .first()
        .expect("Pleasy supply a datasource in your schema.prisma file");
    let (db_name, executor) = executor::load(&source, &[], &url).await?;
    let internal_model = InternalDataModelBuilder::new(DATAMODEL_STR).build(db_name);
    let query_schema = Arc::new(schema_builder::build(
        internal_model,
        BuildMode::Modern,
        true,
        source.capabilities(),
        vec![],
        source.referential_integrity(),
    ));
    executor.primary_connector().get_connection().await?;
    Ok(PrismaClient {
        executor,
        query_schema,
    })
}
impl PrismaClient {
    pub fn migration(&self) -> migration::Actions {
        migration::Actions { client: &self }
    }
    pub fn user(&self) -> user::Actions {
        user::Actions { client: &self }
    }
    pub fn file(&self) -> file::Actions {
        file::Actions { client: &self }
    }
    pub fn media_data(&self) -> media_data::Actions {
        media_data::Actions { client: &self }
    }
    pub fn tag(&self) -> tag::Actions {
        tag::Actions { client: &self }
    }
    pub fn tag_on_file(&self) -> tag_on_file::Actions {
        tag_on_file::Actions { client: &self }
    }
    pub fn job(&self) -> job::Actions {
        job::Actions { client: &self }
    }
}
pub mod migration {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: i32) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod checksum {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::ChecksumEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Checksum(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Checksum(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ChecksumInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::ChecksumNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::ChecksumLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::ChecksumLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::ChecksumGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::ChecksumGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::ChecksumContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::ChecksumStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::ChecksumEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::ChecksumNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetChecksum(value.0)
            }
        }
    }
    pub mod steps_applied {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::StepsAppliedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::StepsApplied(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementStepsApplied(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementStepsApplied(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyStepsApplied(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideStepsApplied(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::StepsAppliedInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::StepsAppliedNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::StepsAppliedLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::StepsAppliedLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::StepsAppliedGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::StepsAppliedGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::StepsAppliedNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStepsApplied(value.0)
            }
        }
    }
    pub mod applied_at {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::AppliedAtEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::AppliedAt(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::AppliedAtInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::AppliedAtNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::AppliedAtLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::AppliedAtLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::AppliedAtGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::AppliedAtGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::AppliedAtNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAppliedAt(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        ["id", "name", "checksum", "steps_applied", "applied_at"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "checksum")]
        pub checksum: String,
        #[serde(rename = "steps_applied")]
        pub steps_applied: i32,
        #[serde(rename = "applied_at")]
        pub applied_at: chrono::DateTime<chrono::FixedOffset>,
    }
    impl Data {}
    pub enum WithParam {}
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {}
        }
    }
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetName(String),
        SetChecksum(String),
        SetStepsApplied(i32),
        IncrementStepsApplied(i32),
        DecrementStepsApplied(i32),
        MultiplyStepsApplied(i32),
        DivideStepsApplied(i32),
        SetAppliedAt(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64).into()),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value).into()),
                SetParam::SetChecksum(value) => {
                    ("checksum".to_string(), PrismaValue::String(value).into())
                }
                SetParam::SetStepsApplied(value) => (
                    "steps_applied".to_string(),
                    PrismaValue::Int(value as i64).into(),
                ),
                SetParam::IncrementStepsApplied(value) => (
                    "steps_applied".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementStepsApplied(value) => (
                    "steps_applied".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyStepsApplied(value) => (
                    "steps_applied".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideStepsApplied(value) => (
                    "steps_applied".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetAppliedAt(value) => (
                    "applied_at".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
        Checksum(Direction),
        StepsApplied(Direction),
        AppliedAt(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::Name(direction) => (
                    "name".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Checksum(direction) => (
                    "checksum".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::StepsApplied(direction) => (
                    "steps_applied".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::AppliedAt(direction) => (
                    "applied_at".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(i32),
        Name(String),
        Checksum(String),
        StepsApplied(i32),
        AppliedAt(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::Name(cursor) => ("name".to_string(), PrismaValue::String(cursor).into()),
                Self::Checksum(cursor) => {
                    ("checksum".to_string(), PrismaValue::String(cursor).into())
                }
                Self::StepsApplied(cursor) => (
                    "steps_applied".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::AppliedAt(cursor) => (
                    "applied_at".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameNot(String),
        ChecksumEquals(String),
        ChecksumInVec(Vec<String>),
        ChecksumNotInVec(Vec<String>),
        ChecksumLt(String),
        ChecksumLte(String),
        ChecksumGt(String),
        ChecksumGte(String),
        ChecksumContains(String),
        ChecksumStartsWith(String),
        ChecksumEndsWith(String),
        ChecksumNot(String),
        StepsAppliedEquals(i32),
        StepsAppliedInVec(Vec<i32>),
        StepsAppliedNotInVec(Vec<i32>),
        StepsAppliedLt(i32),
        StepsAppliedLte(i32),
        StepsAppliedGt(i32),
        StepsAppliedGte(i32),
        StepsAppliedNot(i32),
        AppliedAtEquals(chrono::DateTime<chrono::FixedOffset>),
        AppliedAtInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        AppliedAtNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        AppliedAtLt(chrono::DateTime<chrono::FixedOffset>),
        AppliedAtLte(chrono::DateTime<chrono::FixedOffset>),
        AppliedAtGt(chrono::DateTime<chrono::FixedOffset>),
        AppliedAtGte(chrono::DateTime<chrono::FixedOffset>),
        AppliedAtNot(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::NameEquals(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameLte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameGt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameGte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameContains(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameStartsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameEndsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameNot(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumEquals(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumInVec(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChecksumNotInVec(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::ChecksumLt(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumLte(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumGt(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumGte(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumContains(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumStartsWith(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumEndsWith(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::ChecksumNot(value) => (
                    "checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::StepsAppliedEquals(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StepsAppliedInVec(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::StepsAppliedNotInVec(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::StepsAppliedLt(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StepsAppliedLte(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StepsAppliedGt(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StepsAppliedGte(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StepsAppliedNot(value) => (
                    "steps_applied".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::AppliedAtEquals(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::AppliedAtInVec(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::AppliedAtNotInVec(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::AppliedAtLt(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::AppliedAtLte(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::AppliedAtGt(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::AppliedAtGte(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::AppliedAtNot(value) => (
                    "applied_at".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(i32),
        ChecksumEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::ChecksumEquals(value) => Self::ChecksumEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration", _outputs()))
                .await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration", _outputs()))
                .await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration", _outputs()))
                .await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration", _outputs()))
                .await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx
                .execute(args.to_operation("Migration", _outputs()))
                .await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration", _outputs()))
                .await
        }
        pub fn create(
            mut self,
            name: name::Set,
            checksum: checksum::Set,
            mut params: Vec<SetParam>,
        ) -> Self {
            params.push(name.into());
            params.push(checksum.into());
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx
                .execute(args.to_operation("Migration", _outputs()))
                .await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Migration"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            name: name::Set,
            checksum: checksum::Set,
            mut params: Vec<SetParam>,
        ) -> Create {
            params.push(name.into());
            params.push(checksum.into());
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
pub mod user {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: i32) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod username {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::UsernameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Username(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Username(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UsernameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::UsernameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::UsernameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::UsernameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::UsernameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::UsernameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::UsernameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::UsernameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::UsernameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::UsernameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUsername(value.0)
            }
        }
    }
    pub mod index_dir {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::IndexDirEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::IndexDir(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IndexDirInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IndexDirNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IndexDirLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IndexDirLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IndexDirGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IndexDirGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IndexDirContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IndexDirStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IndexDirEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IndexDirNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIndexDir(value.0)
            }
        }
    }
    pub mod data_dir {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::DataDirEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DataDir(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DataDirInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::DataDirNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::DataDirLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::DataDirLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::DataDirGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::DataDirGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::DataDirContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::DataDirStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::DataDirEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::DataDirNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDataDir(value.0)
            }
        }
    }
    pub mod hostname {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::HostnameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Hostname(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HostnameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::HostnameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::HostnameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::HostnameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::HostnameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::HostnameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::HostnameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::HostnameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::HostnameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::HostnameNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHostname(value.0)
            }
        }
    }
    pub mod platform {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::PlatformEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Platform(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPlatform(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPlatform(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPlatform(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePlatform(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PlatformInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PlatformNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::PlatformLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::PlatformLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::PlatformGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::PlatformGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::PlatformNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPlatform(value.0)
            }
        }
    }
    pub mod date_created {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateCreated(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateCreated(value.0)
            }
        }
    }
    pub mod jobs {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<job::WhereParam>) -> WhereParam {
            WhereParam::JobsSome(value)
        }
        pub fn every(value: Vec<job::WhereParam>) -> WhereParam {
            WhereParam::JobsEvery(value)
        }
        pub fn none(value: Vec<job::WhereParam>) -> WhereParam {
            WhereParam::JobsNone(value)
        }
        pub fn fetch(params: Vec<job::WhereParam>) -> job::FindManyArgs {
            job::FindManyArgs::new(params)
        }
        pub fn link<T: From<Link>>(params: Vec<job::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<job::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkJobs(params)
        }
        pub struct Link(Vec<job::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkJobs(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "username",
            "index_dir",
            "data_dir",
            "hostname",
            "platform",
            "date_created",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "username")]
        pub username: String,
        #[serde(rename = "index_dir")]
        pub index_dir: String,
        #[serde(rename = "data_dir")]
        pub data_dir: String,
        #[serde(rename = "hostname")]
        pub hostname: Option<String>,
        #[serde(rename = "platform")]
        pub platform: i32,
        #[serde(rename = "date_created")]
        pub date_created: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "jobs")]
        jobs: Option<Vec<super::job::Data>>,
    }
    impl Data {
        pub fn jobs(&self) -> Result<&Vec<super::job::Data>, String> {
            match self.jobs.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access jobs but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        Jobs(super::job::FindManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Jobs(args) => {
                    let FindManySelectionArgs {
                        mut nested_selections,
                        arguments,
                    } = args.into();
                    nested_selections.extend(super::job::_outputs());
                    let mut builder = Selection::builder("jobs");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    impl From<super::job::FindManyArgs> for WithParam {
        fn from(args: super::job::FindManyArgs) -> Self {
            Self::Jobs(args)
        }
    }
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetUsername(String),
        SetIndexDir(String),
        SetDataDir(String),
        SetHostname(Option<String>),
        SetPlatform(i32),
        IncrementPlatform(i32),
        DecrementPlatform(i32),
        MultiplyPlatform(i32),
        DividePlatform(i32),
        SetDateCreated(chrono::DateTime<chrono::FixedOffset>),
        LinkJobs(Vec<super::job::UniqueWhereParam>),
        UnlinkJobs(Vec<super::job::UniqueWhereParam>),
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64).into()),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetUsername(value) => {
                    ("username".to_string(), PrismaValue::String(value).into())
                }
                SetParam::SetIndexDir(value) => {
                    ("index_dir".to_string(), PrismaValue::String(value).into())
                }
                SetParam::SetDataDir(value) => {
                    ("data_dir".to_string(), PrismaValue::String(value).into())
                }
                SetParam::SetHostname(value) => (
                    "hostname".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetPlatform(value) => (
                    "platform".to_string(),
                    PrismaValue::Int(value as i64).into(),
                ),
                SetParam::IncrementPlatform(value) => (
                    "platform".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementPlatform(value) => (
                    "platform".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyPlatform(value) => (
                    "platform".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DividePlatform(value) => (
                    "platform".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetDateCreated(value) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::LinkJobs(where_params) => (
                    "jobs".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    where_params
                                        .into_iter()
                                        .map(Into::<super::job::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::UnlinkJobs(where_params) => (
                    "jobs".to_string(),
                    QueryValue::Object(
                        vec![(
                            "disconnect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    where_params
                                        .into_iter()
                                        .map(Into::<super::job::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Username(Direction),
        IndexDir(Direction),
        DataDir(Direction),
        Hostname(Direction),
        Platform(Direction),
        DateCreated(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::Username(direction) => (
                    "username".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::IndexDir(direction) => (
                    "index_dir".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DataDir(direction) => (
                    "data_dir".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Hostname(direction) => (
                    "hostname".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Platform(direction) => (
                    "platform".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateCreated(direction) => (
                    "date_created".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(i32),
        Username(String),
        IndexDir(String),
        DataDir(String),
        Hostname(String),
        Platform(i32),
        DateCreated(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::Username(cursor) => {
                    ("username".to_string(), PrismaValue::String(cursor).into())
                }
                Self::IndexDir(cursor) => {
                    ("index_dir".to_string(), PrismaValue::String(cursor).into())
                }
                Self::DataDir(cursor) => {
                    ("data_dir".to_string(), PrismaValue::String(cursor).into())
                }
                Self::Hostname(cursor) => {
                    ("hostname".to_string(), PrismaValue::String(cursor).into())
                }
                Self::Platform(cursor) => (
                    "platform".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::DateCreated(cursor) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        UsernameEquals(String),
        UsernameInVec(Vec<String>),
        UsernameNotInVec(Vec<String>),
        UsernameLt(String),
        UsernameLte(String),
        UsernameGt(String),
        UsernameGte(String),
        UsernameContains(String),
        UsernameStartsWith(String),
        UsernameEndsWith(String),
        UsernameNot(String),
        IndexDirEquals(String),
        IndexDirInVec(Vec<String>),
        IndexDirNotInVec(Vec<String>),
        IndexDirLt(String),
        IndexDirLte(String),
        IndexDirGt(String),
        IndexDirGte(String),
        IndexDirContains(String),
        IndexDirStartsWith(String),
        IndexDirEndsWith(String),
        IndexDirNot(String),
        DataDirEquals(String),
        DataDirInVec(Vec<String>),
        DataDirNotInVec(Vec<String>),
        DataDirLt(String),
        DataDirLte(String),
        DataDirGt(String),
        DataDirGte(String),
        DataDirContains(String),
        DataDirStartsWith(String),
        DataDirEndsWith(String),
        DataDirNot(String),
        HostnameEquals(Option<String>),
        HostnameInVec(Vec<String>),
        HostnameNotInVec(Vec<String>),
        HostnameLt(String),
        HostnameLte(String),
        HostnameGt(String),
        HostnameGte(String),
        HostnameContains(String),
        HostnameStartsWith(String),
        HostnameEndsWith(String),
        HostnameNot(String),
        PlatformEquals(i32),
        PlatformInVec(Vec<i32>),
        PlatformNotInVec(Vec<i32>),
        PlatformLt(i32),
        PlatformLte(i32),
        PlatformGt(i32),
        PlatformGte(i32),
        PlatformNot(i32),
        DateCreatedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedLt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedLte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedNot(chrono::DateTime<chrono::FixedOffset>),
        JobsSome(Vec<super::job::WhereParam>),
        JobsEvery(Vec<super::job::WhereParam>),
        JobsNone(Vec<super::job::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::UsernameEquals(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameInVec(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsernameNotInVec(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::UsernameLt(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameLte(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameGt(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameGte(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameContains(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameStartsWith(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameEndsWith(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::UsernameNot(value) => (
                    "username".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirEquals(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirInVec(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IndexDirNotInVec(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IndexDirLt(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirLte(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirGt(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirGte(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirContains(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirStartsWith(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirEndsWith(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IndexDirNot(value) => (
                    "index_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirEquals(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirInVec(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DataDirNotInVec(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DataDirLt(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirLte(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirGt(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirGte(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirContains(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirStartsWith(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirEndsWith(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DataDirNot(value) => (
                    "data_dir".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameEquals(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::HostnameInVec(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::HostnameNotInVec(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::HostnameLt(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameLte(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameGt(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameGte(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameContains(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameStartsWith(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameEndsWith(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::HostnameNot(value) => (
                    "hostname".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PlatformEquals(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PlatformInVec(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PlatformNotInVec(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PlatformLt(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PlatformLte(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PlatformGt(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PlatformGte(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PlatformNot(value) => (
                    "platform".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DateCreatedEquals(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedNotInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedLt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedLte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedNot(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::JobsSome(value) => (
                    "jobs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::JobsEvery(value) => (
                    "jobs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::JobsNone(value) => (
                    "jobs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(i32),
        UsernameEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::UsernameEquals(value) => Self::UsernameEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User", _outputs())).await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User", _outputs())).await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("User", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User", _outputs())).await
        }
        pub fn create(
            mut self,
            username: username::Set,
            index_dir: index_dir::Set,
            data_dir: data_dir::Set,
            mut params: Vec<SetParam>,
        ) -> Self {
            params.push(username.into());
            params.push(index_dir.into());
            params.push(data_dir.into());
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("User", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("User"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            username: username::Set,
            index_dir: index_dir::Set,
            data_dir: data_dir::Set,
            mut params: Vec<SetParam>,
        ) -> Create {
            params.push(username.into());
            params.push(index_dir.into());
            params.push(data_dir.into());
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
pub mod file {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: i32) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod cas_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::CasIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CasId(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::CasId(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CasIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CasIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CasIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CasIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CasIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CasIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CasIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CasIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CasIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CasIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCasId(value.0)
            }
        }
    }
    pub mod integrity_checksum {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals<A, T: prisma_client_rust::traits::FromOptionalUniqueArg<Set, Arg = A>>(
            value: A,
        ) -> T {
            T::from_arg(value)
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::IntegrityChecksum(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::IntegrityChecksum(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IntegrityChecksumInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IntegrityChecksumNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IntegrityChecksumNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIntegrityChecksum(value.0)
            }
        }
    }
    pub mod kind {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::KindEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Kind(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKind(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKind(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKind(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKind(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KindInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KindNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::KindLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::KindLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::KindGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::KindGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::KindNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKind(value.0)
            }
        }
    }
    pub mod size_in_bytes {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::SizeInBytesEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::SizeInBytes(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SizeInBytesInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::SizeInBytesNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::SizeInBytesLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::SizeInBytesLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::SizeInBytesGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::SizeInBytesGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::SizeInBytesContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::SizeInBytesStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::SizeInBytesEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::SizeInBytesNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSizeInBytes(value.0)
            }
        }
    }
    pub mod key_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::KeyIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::KeyId(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementKeyId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementKeyId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyKeyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideKeyId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KeyIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::KeyIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::KeyIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::KeyIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::KeyIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::KeyIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::KeyIdNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetKeyId(value.0)
            }
        }
    }
    pub mod hidden {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::HiddenEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Hidden(direction)
        }
        pub struct Set(bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHidden(value.0)
            }
        }
    }
    pub mod favorite {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::FavoriteEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Favorite(direction)
        }
        pub struct Set(bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetFavorite(value.0)
            }
        }
    }
    pub mod important {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::ImportantEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Important(direction)
        }
        pub struct Set(bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetImportant(value.0)
            }
        }
    }
    pub mod has_thumbnail {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::HasThumbnailEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::HasThumbnail(direction)
        }
        pub struct Set(bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHasThumbnail(value.0)
            }
        }
    }
    pub mod has_thumbstrip {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::HasThumbstripEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::HasThumbstrip(direction)
        }
        pub struct Set(bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHasThumbstrip(value.0)
            }
        }
    }
    pub mod has_video_preview {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: bool) -> T {
            Set(value).into()
        }
        pub fn equals(value: bool) -> WhereParam {
            WhereParam::HasVideoPreviewEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::HasVideoPreview(direction)
        }
        pub struct Set(bool);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetHasVideoPreview(value.0)
            }
        }
    }
    pub mod ipfs_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::IpfsIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::IpfsId(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IpfsIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IpfsIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IpfsIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IpfsIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IpfsIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IpfsIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IpfsIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IpfsIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IpfsIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IpfsIdNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetIpfsId(value.0)
            }
        }
    }
    pub mod comment {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CommentEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Comment(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CommentInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CommentNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CommentLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CommentLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CommentGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CommentGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CommentContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CommentStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CommentEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CommentNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetComment(value.0)
            }
        }
    }
    pub mod date_created {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateCreated(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateCreated(value.0)
            }
        }
    }
    pub mod date_modified {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateModified(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateModifiedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateModifiedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateModified(value.0)
            }
        }
    }
    pub mod date_indexed {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateIndexedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateIndexed(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateIndexedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateIndexedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateIndexedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateIndexedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateIndexedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateIndexedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateIndexedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateIndexed(value.0)
            }
        }
    }
    pub mod tags {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
            WhereParam::TagsSome(value)
        }
        pub fn every(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
            WhereParam::TagsEvery(value)
        }
        pub fn none(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
            WhereParam::TagsNone(value)
        }
        pub fn fetch(params: Vec<tag_on_file::WhereParam>) -> tag_on_file::FindManyArgs {
            tag_on_file::FindManyArgs::new(params)
        }
        pub fn link<T: From<Link>>(params: Vec<tag_on_file::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<tag_on_file::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkTags(params)
        }
        pub struct Link(Vec<tag_on_file::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkTags(value.0)
            }
        }
    }
    pub mod media_data {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<media_data::WhereParam>) -> WhereParam {
            WhereParam::MediaDataIs(value)
        }
        pub fn is_not(value: Vec<media_data::WhereParam>) -> WhereParam {
            WhereParam::MediaDataIsNot(value)
        }
        pub fn fetch() -> media_data::Args {
            media_data::Args::new()
        }
        pub fn link<T: From<Link>>(value: media_data::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkMediaData
        }
        pub struct Link(media_data::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkMediaData(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "cas_id",
            "integrity_checksum",
            "kind",
            "size_in_bytes",
            "key_id",
            "hidden",
            "favorite",
            "important",
            "has_thumbnail",
            "has_thumbstrip",
            "has_video_preview",
            "ipfs_id",
            "comment",
            "date_created",
            "date_modified",
            "date_indexed",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "cas_id")]
        pub cas_id: String,
        #[serde(rename = "integrity_checksum")]
        pub integrity_checksum: Option<String>,
        #[serde(rename = "kind")]
        pub kind: i32,
        #[serde(rename = "size_in_bytes")]
        pub size_in_bytes: String,
        #[serde(rename = "key_id")]
        pub key_id: Option<i32>,
        #[serde(rename = "hidden")]
        pub hidden: bool,
        #[serde(rename = "favorite")]
        pub favorite: bool,
        #[serde(rename = "important")]
        pub important: bool,
        #[serde(rename = "has_thumbnail")]
        pub has_thumbnail: bool,
        #[serde(rename = "has_thumbstrip")]
        pub has_thumbstrip: bool,
        #[serde(rename = "has_video_preview")]
        pub has_video_preview: bool,
        #[serde(rename = "ipfs_id")]
        pub ipfs_id: Option<String>,
        #[serde(rename = "comment")]
        pub comment: Option<String>,
        #[serde(rename = "date_created")]
        pub date_created: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "date_modified")]
        pub date_modified: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "date_indexed")]
        pub date_indexed: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "tags")]
        tags: Option<Vec<super::tag_on_file::Data>>,
        #[serde(rename = "media_data")]
        media_data: Option<Option<Box<super::media_data::Data>>>,
    }
    impl Data {
        pub fn tags(&self) -> Result<&Vec<super::tag_on_file::Data>, String> {
            match self.tags.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access tags but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
        pub fn media_data(&self) -> Result<Option<&super::media_data::Data>, String> {
            match self.media_data.as_ref() {
                Some(v) => Ok(v.as_ref().map(|v| v.as_ref())),
                None => Err(
                    "Attempted to access media_data but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        Tags(super::tag_on_file::FindManyArgs),
        MediaData(super::media_data::Args),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Tags(args) => {
                    let FindManySelectionArgs {
                        mut nested_selections,
                        arguments,
                    } = args.into();
                    nested_selections.extend(super::tag_on_file::_outputs());
                    let mut builder = Selection::builder("tags");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
                Self::MediaData(args) => {
                    let mut selections = super::media_data::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("media_data");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    impl From<super::tag_on_file::FindManyArgs> for WithParam {
        fn from(args: super::tag_on_file::FindManyArgs) -> Self {
            Self::Tags(args)
        }
    }
    impl From<super::media_data::Args> for WithParam {
        fn from(args: super::media_data::Args) -> Self {
            Self::MediaData(args)
        }
    }
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetCasId(String),
        SetIntegrityChecksum(Option<String>),
        SetKind(i32),
        IncrementKind(i32),
        DecrementKind(i32),
        MultiplyKind(i32),
        DivideKind(i32),
        SetSizeInBytes(String),
        SetKeyId(Option<i32>),
        IncrementKeyId(i32),
        DecrementKeyId(i32),
        MultiplyKeyId(i32),
        DivideKeyId(i32),
        SetHidden(bool),
        SetFavorite(bool),
        SetImportant(bool),
        SetHasThumbnail(bool),
        SetHasThumbstrip(bool),
        SetHasVideoPreview(bool),
        SetIpfsId(Option<String>),
        SetComment(Option<String>),
        SetDateCreated(chrono::DateTime<chrono::FixedOffset>),
        SetDateModified(chrono::DateTime<chrono::FixedOffset>),
        SetDateIndexed(chrono::DateTime<chrono::FixedOffset>),
        LinkTags(Vec<super::tag_on_file::UniqueWhereParam>),
        UnlinkTags(Vec<super::tag_on_file::UniqueWhereParam>),
        LinkMediaData(super::media_data::UniqueWhereParam),
        UnlinkMediaData,
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64).into()),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetCasId(value) => {
                    ("cas_id".to_string(), PrismaValue::String(value).into())
                }
                SetParam::SetIntegrityChecksum(value) => (
                    "integrity_checksum".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetKind(value) => {
                    ("kind".to_string(), PrismaValue::Int(value as i64).into())
                }
                SetParam::IncrementKind(value) => (
                    "kind".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementKind(value) => (
                    "kind".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyKind(value) => (
                    "kind".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideKind(value) => (
                    "kind".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetSizeInBytes(value) => (
                    "size_in_bytes".to_string(),
                    PrismaValue::String(value).into(),
                ),
                SetParam::SetKeyId(value) => (
                    "key_id".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementKeyId(value) => (
                    "key_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementKeyId(value) => (
                    "key_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyKeyId(value) => (
                    "key_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideKeyId(value) => (
                    "key_id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetHidden(value) => {
                    ("hidden".to_string(), PrismaValue::Boolean(value).into())
                }
                SetParam::SetFavorite(value) => {
                    ("favorite".to_string(), PrismaValue::Boolean(value).into())
                }
                SetParam::SetImportant(value) => {
                    ("important".to_string(), PrismaValue::Boolean(value).into())
                }
                SetParam::SetHasThumbnail(value) => (
                    "has_thumbnail".to_string(),
                    PrismaValue::Boolean(value).into(),
                ),
                SetParam::SetHasThumbstrip(value) => (
                    "has_thumbstrip".to_string(),
                    PrismaValue::Boolean(value).into(),
                ),
                SetParam::SetHasVideoPreview(value) => (
                    "has_video_preview".to_string(),
                    PrismaValue::Boolean(value).into(),
                ),
                SetParam::SetIpfsId(value) => (
                    "ipfs_id".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetComment(value) => (
                    "comment".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetDateCreated(value) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::SetDateModified(value) => (
                    "date_modified".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::SetDateIndexed(value) => (
                    "date_indexed".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::LinkTags(where_params) => (
                    "tags".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    where_params
                                        .into_iter()
                                        .map(Into::<super::tag_on_file::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::UnlinkTags(where_params) => (
                    "tags".to_string(),
                    QueryValue::Object(
                        vec![(
                            "disconnect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    where_params
                                        .into_iter()
                                        .map(Into::<super::tag_on_file::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::LinkMediaData(where_param) => (
                    "media_data".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    vec![where_param]
                                        .into_iter()
                                        .map(Into::<super::media_data::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::UnlinkMediaData => (
                    "media_data".to_string(),
                    QueryValue::Object(
                        vec![("disconnect".to_string(), QueryValue::Boolean(true))]
                            .into_iter()
                            .collect(),
                    ),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        CasId(Direction),
        IntegrityChecksum(Direction),
        Kind(Direction),
        SizeInBytes(Direction),
        KeyId(Direction),
        Hidden(Direction),
        Favorite(Direction),
        Important(Direction),
        HasThumbnail(Direction),
        HasThumbstrip(Direction),
        HasVideoPreview(Direction),
        IpfsId(Direction),
        Comment(Direction),
        DateCreated(Direction),
        DateModified(Direction),
        DateIndexed(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::CasId(direction) => (
                    "cas_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::IntegrityChecksum(direction) => (
                    "integrity_checksum".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Kind(direction) => (
                    "kind".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::SizeInBytes(direction) => (
                    "size_in_bytes".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::KeyId(direction) => (
                    "key_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Hidden(direction) => (
                    "hidden".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Favorite(direction) => (
                    "favorite".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Important(direction) => (
                    "important".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::HasThumbnail(direction) => (
                    "has_thumbnail".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::HasThumbstrip(direction) => (
                    "has_thumbstrip".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::HasVideoPreview(direction) => (
                    "has_video_preview".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::IpfsId(direction) => (
                    "ipfs_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Comment(direction) => (
                    "comment".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateCreated(direction) => (
                    "date_created".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateModified(direction) => (
                    "date_modified".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateIndexed(direction) => (
                    "date_indexed".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(i32),
        CasId(String),
        IntegrityChecksum(String),
        Kind(i32),
        SizeInBytes(String),
        KeyId(i32),
        Hidden(bool),
        Favorite(bool),
        Important(bool),
        HasThumbnail(bool),
        HasThumbstrip(bool),
        HasVideoPreview(bool),
        IpfsId(String),
        Comment(String),
        DateCreated(chrono::DateTime<chrono::FixedOffset>),
        DateModified(chrono::DateTime<chrono::FixedOffset>),
        DateIndexed(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::CasId(cursor) => ("cas_id".to_string(), PrismaValue::String(cursor).into()),
                Self::IntegrityChecksum(cursor) => (
                    "integrity_checksum".to_string(),
                    PrismaValue::String(cursor).into(),
                ),
                Self::Kind(cursor) => ("kind".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::SizeInBytes(cursor) => (
                    "size_in_bytes".to_string(),
                    PrismaValue::String(cursor).into(),
                ),
                Self::KeyId(cursor) => {
                    ("key_id".to_string(), PrismaValue::Int(cursor as i64).into())
                }
                Self::Hidden(cursor) => ("hidden".to_string(), PrismaValue::Boolean(cursor).into()),
                Self::Favorite(cursor) => {
                    ("favorite".to_string(), PrismaValue::Boolean(cursor).into())
                }
                Self::Important(cursor) => {
                    ("important".to_string(), PrismaValue::Boolean(cursor).into())
                }
                Self::HasThumbnail(cursor) => (
                    "has_thumbnail".to_string(),
                    PrismaValue::Boolean(cursor).into(),
                ),
                Self::HasThumbstrip(cursor) => (
                    "has_thumbstrip".to_string(),
                    PrismaValue::Boolean(cursor).into(),
                ),
                Self::HasVideoPreview(cursor) => (
                    "has_video_preview".to_string(),
                    PrismaValue::Boolean(cursor).into(),
                ),
                Self::IpfsId(cursor) => ("ipfs_id".to_string(), PrismaValue::String(cursor).into()),
                Self::Comment(cursor) => {
                    ("comment".to_string(), PrismaValue::String(cursor).into())
                }
                Self::DateCreated(cursor) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
                Self::DateModified(cursor) => (
                    "date_modified".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
                Self::DateIndexed(cursor) => (
                    "date_indexed".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        CasIdEquals(String),
        CasIdInVec(Vec<String>),
        CasIdNotInVec(Vec<String>),
        CasIdLt(String),
        CasIdLte(String),
        CasIdGt(String),
        CasIdGte(String),
        CasIdContains(String),
        CasIdStartsWith(String),
        CasIdEndsWith(String),
        CasIdNot(String),
        IntegrityChecksumEquals(Option<String>),
        IntegrityChecksumInVec(Vec<String>),
        IntegrityChecksumNotInVec(Vec<String>),
        IntegrityChecksumLt(String),
        IntegrityChecksumLte(String),
        IntegrityChecksumGt(String),
        IntegrityChecksumGte(String),
        IntegrityChecksumContains(String),
        IntegrityChecksumStartsWith(String),
        IntegrityChecksumEndsWith(String),
        IntegrityChecksumNot(String),
        KindEquals(i32),
        KindInVec(Vec<i32>),
        KindNotInVec(Vec<i32>),
        KindLt(i32),
        KindLte(i32),
        KindGt(i32),
        KindGte(i32),
        KindNot(i32),
        SizeInBytesEquals(String),
        SizeInBytesInVec(Vec<String>),
        SizeInBytesNotInVec(Vec<String>),
        SizeInBytesLt(String),
        SizeInBytesLte(String),
        SizeInBytesGt(String),
        SizeInBytesGte(String),
        SizeInBytesContains(String),
        SizeInBytesStartsWith(String),
        SizeInBytesEndsWith(String),
        SizeInBytesNot(String),
        KeyIdEquals(Option<i32>),
        KeyIdInVec(Vec<i32>),
        KeyIdNotInVec(Vec<i32>),
        KeyIdLt(i32),
        KeyIdLte(i32),
        KeyIdGt(i32),
        KeyIdGte(i32),
        KeyIdNot(i32),
        HiddenEquals(bool),
        FavoriteEquals(bool),
        ImportantEquals(bool),
        HasThumbnailEquals(bool),
        HasThumbstripEquals(bool),
        HasVideoPreviewEquals(bool),
        IpfsIdEquals(Option<String>),
        IpfsIdInVec(Vec<String>),
        IpfsIdNotInVec(Vec<String>),
        IpfsIdLt(String),
        IpfsIdLte(String),
        IpfsIdGt(String),
        IpfsIdGte(String),
        IpfsIdContains(String),
        IpfsIdStartsWith(String),
        IpfsIdEndsWith(String),
        IpfsIdNot(String),
        CommentEquals(Option<String>),
        CommentInVec(Vec<String>),
        CommentNotInVec(Vec<String>),
        CommentLt(String),
        CommentLte(String),
        CommentGt(String),
        CommentGte(String),
        CommentContains(String),
        CommentStartsWith(String),
        CommentEndsWith(String),
        CommentNot(String),
        DateCreatedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedLt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedLte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedNot(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateModifiedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateModifiedLt(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedLte(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedGt(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedGte(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedNot(chrono::DateTime<chrono::FixedOffset>),
        DateIndexedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateIndexedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateIndexedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateIndexedLt(chrono::DateTime<chrono::FixedOffset>),
        DateIndexedLte(chrono::DateTime<chrono::FixedOffset>),
        DateIndexedGt(chrono::DateTime<chrono::FixedOffset>),
        DateIndexedGte(chrono::DateTime<chrono::FixedOffset>),
        DateIndexedNot(chrono::DateTime<chrono::FixedOffset>),
        TagsSome(Vec<super::tag_on_file::WhereParam>),
        TagsEvery(Vec<super::tag_on_file::WhereParam>),
        TagsNone(Vec<super::tag_on_file::WhereParam>),
        MediaDataIs(Vec<super::media_data::WhereParam>),
        MediaDataIsNot(Vec<super::media_data::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CasIdEquals(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdInVec(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CasIdNotInVec(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CasIdLt(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdLte(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdGt(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdGte(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdContains(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdStartsWith(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdEndsWith(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CasIdNot(value) => (
                    "cas_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumEquals(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::IntegrityChecksumInVec(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IntegrityChecksumNotInVec(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IntegrityChecksumLt(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumLte(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumGt(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumGte(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumContains(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumStartsWith(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumEndsWith(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IntegrityChecksumNot(value) => (
                    "integrity_checksum".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::KindEquals(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KindInVec(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::KindNotInVec(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::KindLt(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KindLte(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KindGt(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KindGte(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KindNot(value) => (
                    "kind".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::SizeInBytesEquals(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesInVec(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::SizeInBytesNotInVec(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::SizeInBytesLt(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesLte(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesGt(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesGte(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesContains(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesStartsWith(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesEndsWith(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::SizeInBytesNot(value) => (
                    "size_in_bytes".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::KeyIdEquals(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::KeyIdInVec(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::KeyIdNotInVec(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::KeyIdLt(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KeyIdLte(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KeyIdGt(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KeyIdGte(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::KeyIdNot(value) => (
                    "key_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::HiddenEquals(value) => (
                    "hidden".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Boolean(value).into(),
                    )]),
                ),
                Self::FavoriteEquals(value) => (
                    "favorite".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Boolean(value).into(),
                    )]),
                ),
                Self::ImportantEquals(value) => (
                    "important".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Boolean(value).into(),
                    )]),
                ),
                Self::HasThumbnailEquals(value) => (
                    "has_thumbnail".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Boolean(value).into(),
                    )]),
                ),
                Self::HasThumbstripEquals(value) => (
                    "has_thumbstrip".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Boolean(value).into(),
                    )]),
                ),
                Self::HasVideoPreviewEquals(value) => (
                    "has_video_preview".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Boolean(value).into(),
                    )]),
                ),
                Self::IpfsIdEquals(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::IpfsIdInVec(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IpfsIdNotInVec(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IpfsIdLt(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdLte(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdGt(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdGte(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdContains(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdStartsWith(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdEndsWith(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IpfsIdNot(value) => (
                    "ipfs_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentEquals(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::CommentInVec(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CommentNotInVec(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CommentLt(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentLte(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentGt(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentGte(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentContains(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentStartsWith(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentEndsWith(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CommentNot(value) => (
                    "comment".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DateCreatedEquals(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedNotInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedLt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedLte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedNot(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedEquals(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedInVec(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateModifiedNotInVec(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateModifiedLt(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedLte(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedGt(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedGte(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedNot(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateIndexedEquals(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateIndexedInVec(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateIndexedNotInVec(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateIndexedLt(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateIndexedLte(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateIndexedGt(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateIndexedGte(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateIndexedNot(value) => (
                    "date_indexed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::TagsSome(value) => (
                    "tags".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagsEvery(value) => (
                    "tags".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagsNone(value) => (
                    "tags".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::MediaDataIs(value) => (
                    "media_data".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::MediaDataIsNot(value) => (
                    "media_data".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(i32),
        CasIdEquals(String),
        IntegrityChecksumEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::CasIdEquals(value) => Self::CasIdEquals(value),
                UniqueWhereParam::IntegrityChecksumEquals(value) => {
                    Self::IntegrityChecksumEquals(Some(value))
                }
            }
        }
    }
    impl prisma_client_rust::traits::FromOptionalUniqueArg<integrity_checksum::Set> for WhereParam {
        type Arg = Option<String>;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::IntegrityChecksumEquals(arg)
        }
    }
    impl prisma_client_rust::traits::FromOptionalUniqueArg<integrity_checksum::Set>
        for UniqueWhereParam
    {
        type Arg = String;
        fn from_arg(arg: Self::Arg) -> Self
        where
            Self: Sized,
        {
            Self::IntegrityChecksumEquals(arg)
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File", _outputs())).await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File", _outputs())).await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("File", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File", _outputs())).await
        }
        pub fn create(
            mut self,
            cas_id: cas_id::Set,
            size_in_bytes: size_in_bytes::Set,
            mut params: Vec<SetParam>,
        ) -> Self {
            params.push(cas_id.into());
            params.push(size_in_bytes.into());
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("File", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("File"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            cas_id: cas_id::Set,
            size_in_bytes: size_in_bytes::Set,
            mut params: Vec<SetParam>,
        ) -> Create {
            params.push(cas_id.into());
            params.push(size_in_bytes.into());
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
pub mod media_data {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: i32) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod pixel_width {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::PixelWidthEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PixelWidth(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPixelWidth(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPixelWidth(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPixelWidth(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePixelWidth(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PixelWidthInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PixelWidthNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::PixelWidthLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::PixelWidthLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::PixelWidthGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::PixelWidthGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::PixelWidthNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPixelWidth(value.0)
            }
        }
    }
    pub mod pixel_height {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::PixelHeightEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PixelHeight(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementPixelHeight(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementPixelHeight(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyPixelHeight(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DividePixelHeight(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PixelHeightInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::PixelHeightNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::PixelHeightLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::PixelHeightLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::PixelHeightGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::PixelHeightGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::PixelHeightNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPixelHeight(value.0)
            }
        }
    }
    pub mod longitude {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<f64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<f64>) -> WhereParam {
            WhereParam::LongitudeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Longitude(direction)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementLongitude(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementLongitude(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyLongitude(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DivideLongitude(value)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::LongitudeInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::LongitudeNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::LongitudeLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::LongitudeLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::LongitudeGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::LongitudeGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::LongitudeNot(value)
        }
        pub struct Set(Option<f64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLongitude(value.0)
            }
        }
    }
    pub mod latitude {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<f64>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<f64>) -> WhereParam {
            WhereParam::LatitudeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Latitude(direction)
        }
        pub fn increment(value: f64) -> SetParam {
            SetParam::IncrementLatitude(value)
        }
        pub fn decrement(value: f64) -> SetParam {
            SetParam::DecrementLatitude(value)
        }
        pub fn multiply(value: f64) -> SetParam {
            SetParam::MultiplyLatitude(value)
        }
        pub fn divide(value: f64) -> SetParam {
            SetParam::DivideLatitude(value)
        }
        pub fn in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::LatitudeInVec(value)
        }
        pub fn not_in_vec(value: Vec<f64>) -> WhereParam {
            WhereParam::LatitudeNotInVec(value)
        }
        pub fn lt(value: f64) -> WhereParam {
            WhereParam::LatitudeLt(value)
        }
        pub fn lte(value: f64) -> WhereParam {
            WhereParam::LatitudeLte(value)
        }
        pub fn gt(value: f64) -> WhereParam {
            WhereParam::LatitudeGt(value)
        }
        pub fn gte(value: f64) -> WhereParam {
            WhereParam::LatitudeGte(value)
        }
        pub fn not(value: f64) -> WhereParam {
            WhereParam::LatitudeNot(value)
        }
        pub struct Set(Option<f64>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetLatitude(value.0)
            }
        }
    }
    pub mod fps {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::FpsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Fps(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFps(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFps(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFps(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFps(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::FpsInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::FpsNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::FpsLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::FpsLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::FpsGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::FpsGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::FpsNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetFps(value.0)
            }
        }
    }
    pub mod capture_device_make {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CaptureDeviceMakeEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CaptureDeviceMake(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CaptureDeviceMakeInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CaptureDeviceMakeNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CaptureDeviceMakeNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCaptureDeviceMake(value.0)
            }
        }
    }
    pub mod capture_device_model {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CaptureDeviceModelEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CaptureDeviceModel(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CaptureDeviceModelInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CaptureDeviceModelNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CaptureDeviceModelNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCaptureDeviceModel(value.0)
            }
        }
    }
    pub mod capture_device_software {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CaptureDeviceSoftware(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CaptureDeviceSoftwareNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCaptureDeviceSoftware(value.0)
            }
        }
    }
    pub mod duration_seconds {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::DurationSecondsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DurationSeconds(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementDurationSeconds(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementDurationSeconds(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyDurationSeconds(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideDurationSeconds(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::DurationSecondsInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::DurationSecondsNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::DurationSecondsLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::DurationSecondsLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::DurationSecondsGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::DurationSecondsGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::DurationSecondsNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDurationSeconds(value.0)
            }
        }
    }
    pub mod codecs {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::CodecsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Codecs(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CodecsInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::CodecsNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::CodecsLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::CodecsLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::CodecsGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::CodecsGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::CodecsContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::CodecsStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::CodecsEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::CodecsNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCodecs(value.0)
            }
        }
    }
    pub mod streams {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::StreamsEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Streams(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementStreams(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementStreams(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyStreams(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideStreams(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::StreamsInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::StreamsNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::StreamsLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::StreamsLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::StreamsGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::StreamsGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::StreamsNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStreams(value.0)
            }
        }
    }
    pub mod files {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<file::WhereParam>) -> WhereParam {
            WhereParam::FilesIs(value)
        }
        pub fn is_not(value: Vec<file::WhereParam>) -> WhereParam {
            WhereParam::FilesIsNot(value)
        }
        pub fn fetch() -> file::Args {
            file::Args::new()
        }
        pub fn link<T: From<Link>>(value: file::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkFiles
        }
        pub struct Link(file::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkFiles(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "pixel_width",
            "pixel_height",
            "longitude",
            "latitude",
            "fps",
            "capture_device_make",
            "capture_device_model",
            "capture_device_software",
            "duration_seconds",
            "codecs",
            "streams",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "pixel_width")]
        pub pixel_width: Option<i32>,
        #[serde(rename = "pixel_height")]
        pub pixel_height: Option<i32>,
        #[serde(rename = "longitude")]
        pub longitude: Option<f64>,
        #[serde(rename = "latitude")]
        pub latitude: Option<f64>,
        #[serde(rename = "fps")]
        pub fps: Option<i32>,
        #[serde(rename = "capture_device_make")]
        pub capture_device_make: Option<String>,
        #[serde(rename = "capture_device_model")]
        pub capture_device_model: Option<String>,
        #[serde(rename = "capture_device_software")]
        pub capture_device_software: Option<String>,
        #[serde(rename = "duration_seconds")]
        pub duration_seconds: Option<i32>,
        #[serde(rename = "codecs")]
        pub codecs: Option<String>,
        #[serde(rename = "streams")]
        pub streams: Option<i32>,
        #[serde(rename = "files")]
        files: Option<Option<Box<super::file::Data>>>,
    }
    impl Data {
        pub fn files(&self) -> Result<Option<&super::file::Data>, String> {
            match self.files.as_ref() {
                Some(v) => Ok(v.as_ref().map(|v| v.as_ref())),
                None => Err(
                    "Attempted to access files but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        Files(super::file::Args),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Files(args) => {
                    let mut selections = super::file::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("files");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    impl From<super::file::Args> for WithParam {
        fn from(args: super::file::Args) -> Self {
            Self::Files(args)
        }
    }
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetPixelWidth(Option<i32>),
        IncrementPixelWidth(i32),
        DecrementPixelWidth(i32),
        MultiplyPixelWidth(i32),
        DividePixelWidth(i32),
        SetPixelHeight(Option<i32>),
        IncrementPixelHeight(i32),
        DecrementPixelHeight(i32),
        MultiplyPixelHeight(i32),
        DividePixelHeight(i32),
        SetLongitude(Option<f64>),
        IncrementLongitude(f64),
        DecrementLongitude(f64),
        MultiplyLongitude(f64),
        DivideLongitude(f64),
        SetLatitude(Option<f64>),
        IncrementLatitude(f64),
        DecrementLatitude(f64),
        MultiplyLatitude(f64),
        DivideLatitude(f64),
        SetFps(Option<i32>),
        IncrementFps(i32),
        DecrementFps(i32),
        MultiplyFps(i32),
        DivideFps(i32),
        SetCaptureDeviceMake(Option<String>),
        SetCaptureDeviceModel(Option<String>),
        SetCaptureDeviceSoftware(Option<String>),
        SetDurationSeconds(Option<i32>),
        IncrementDurationSeconds(i32),
        DecrementDurationSeconds(i32),
        MultiplyDurationSeconds(i32),
        DivideDurationSeconds(i32),
        SetCodecs(Option<String>),
        SetStreams(Option<i32>),
        IncrementStreams(i32),
        DecrementStreams(i32),
        MultiplyStreams(i32),
        DivideStreams(i32),
        LinkFiles(super::file::UniqueWhereParam),
        UnlinkFiles,
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64).into()),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetPixelWidth(value) => (
                    "pixel_width".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementPixelWidth(value) => (
                    "pixel_width".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementPixelWidth(value) => (
                    "pixel_width".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyPixelWidth(value) => (
                    "pixel_width".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DividePixelWidth(value) => (
                    "pixel_width".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetPixelHeight(value) => (
                    "pixel_height".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementPixelHeight(value) => (
                    "pixel_height".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementPixelHeight(value) => (
                    "pixel_height".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyPixelHeight(value) => (
                    "pixel_height".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DividePixelHeight(value) => (
                    "pixel_height".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetLongitude(value) => (
                    "longitude".to_string(),
                    value
                        .map(|value| {
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into()
                        })
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementLongitude(value) => (
                    "longitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementLongitude(value) => (
                    "longitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyLongitude(value) => (
                    "longitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideLongitude(value) => (
                    "longitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "divide".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::SetLatitude(value) => (
                    "latitude".to_string(),
                    value
                        .map(|value| {
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into()
                        })
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementLatitude(value) => (
                    "latitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementLatitude(value) => (
                    "latitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyLatitude(value) => (
                    "latitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideLatitude(value) => (
                    "latitude".to_string(),
                    QueryValue::Object(
                        vec![(
                            "divide".to_string(),
                            PrismaValue::Float(
                                bigdecimal::BigDecimal::from_f64(value)
                                    .unwrap()
                                    .normalized(),
                            )
                            .into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::SetFps(value) => (
                    "fps".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementFps(value) => (
                    "fps".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementFps(value) => (
                    "fps".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyFps(value) => (
                    "fps".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideFps(value) => (
                    "fps".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetCaptureDeviceMake(value) => (
                    "capture_device_make".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetCaptureDeviceModel(value) => (
                    "capture_device_model".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetCaptureDeviceSoftware(value) => (
                    "capture_device_software".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetDurationSeconds(value) => (
                    "duration_seconds".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementDurationSeconds(value) => (
                    "duration_seconds".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementDurationSeconds(value) => (
                    "duration_seconds".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyDurationSeconds(value) => (
                    "duration_seconds".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideDurationSeconds(value) => (
                    "duration_seconds".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetCodecs(value) => (
                    "codecs".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetStreams(value) => (
                    "streams".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementStreams(value) => (
                    "streams".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementStreams(value) => (
                    "streams".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyStreams(value) => (
                    "streams".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideStreams(value) => (
                    "streams".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::LinkFiles(where_param) => (
                    "files".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    vec![where_param]
                                        .into_iter()
                                        .map(Into::<super::file::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::UnlinkFiles => (
                    "files".to_string(),
                    QueryValue::Object(
                        vec![("disconnect".to_string(), QueryValue::Boolean(true))]
                            .into_iter()
                            .collect(),
                    ),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        PixelWidth(Direction),
        PixelHeight(Direction),
        Longitude(Direction),
        Latitude(Direction),
        Fps(Direction),
        CaptureDeviceMake(Direction),
        CaptureDeviceModel(Direction),
        CaptureDeviceSoftware(Direction),
        DurationSeconds(Direction),
        Codecs(Direction),
        Streams(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::PixelWidth(direction) => (
                    "pixel_width".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::PixelHeight(direction) => (
                    "pixel_height".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Longitude(direction) => (
                    "longitude".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Latitude(direction) => (
                    "latitude".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Fps(direction) => {
                    ("fps".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::CaptureDeviceMake(direction) => (
                    "capture_device_make".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::CaptureDeviceModel(direction) => (
                    "capture_device_model".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::CaptureDeviceSoftware(direction) => (
                    "capture_device_software".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DurationSeconds(direction) => (
                    "duration_seconds".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Codecs(direction) => (
                    "codecs".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Streams(direction) => (
                    "streams".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(i32),
        PixelWidth(i32),
        PixelHeight(i32),
        Longitude(f64),
        Latitude(f64),
        Fps(i32),
        CaptureDeviceMake(String),
        CaptureDeviceModel(String),
        CaptureDeviceSoftware(String),
        DurationSeconds(i32),
        Codecs(String),
        Streams(i32),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::PixelWidth(cursor) => (
                    "pixel_width".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::PixelHeight(cursor) => (
                    "pixel_height".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::Longitude(cursor) => (
                    "longitude".to_string(),
                    PrismaValue::Float(
                        bigdecimal::BigDecimal::from_f64(cursor)
                            .unwrap()
                            .normalized(),
                    )
                    .into(),
                ),
                Self::Latitude(cursor) => (
                    "latitude".to_string(),
                    PrismaValue::Float(
                        bigdecimal::BigDecimal::from_f64(cursor)
                            .unwrap()
                            .normalized(),
                    )
                    .into(),
                ),
                Self::Fps(cursor) => ("fps".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::CaptureDeviceMake(cursor) => (
                    "capture_device_make".to_string(),
                    PrismaValue::String(cursor).into(),
                ),
                Self::CaptureDeviceModel(cursor) => (
                    "capture_device_model".to_string(),
                    PrismaValue::String(cursor).into(),
                ),
                Self::CaptureDeviceSoftware(cursor) => (
                    "capture_device_software".to_string(),
                    PrismaValue::String(cursor).into(),
                ),
                Self::DurationSeconds(cursor) => (
                    "duration_seconds".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::Codecs(cursor) => ("codecs".to_string(), PrismaValue::String(cursor).into()),
                Self::Streams(cursor) => (
                    "streams".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        PixelWidthEquals(Option<i32>),
        PixelWidthInVec(Vec<i32>),
        PixelWidthNotInVec(Vec<i32>),
        PixelWidthLt(i32),
        PixelWidthLte(i32),
        PixelWidthGt(i32),
        PixelWidthGte(i32),
        PixelWidthNot(i32),
        PixelHeightEquals(Option<i32>),
        PixelHeightInVec(Vec<i32>),
        PixelHeightNotInVec(Vec<i32>),
        PixelHeightLt(i32),
        PixelHeightLte(i32),
        PixelHeightGt(i32),
        PixelHeightGte(i32),
        PixelHeightNot(i32),
        LongitudeEquals(Option<f64>),
        LongitudeInVec(Vec<f64>),
        LongitudeNotInVec(Vec<f64>),
        LongitudeLt(f64),
        LongitudeLte(f64),
        LongitudeGt(f64),
        LongitudeGte(f64),
        LongitudeNot(f64),
        LatitudeEquals(Option<f64>),
        LatitudeInVec(Vec<f64>),
        LatitudeNotInVec(Vec<f64>),
        LatitudeLt(f64),
        LatitudeLte(f64),
        LatitudeGt(f64),
        LatitudeGte(f64),
        LatitudeNot(f64),
        FpsEquals(Option<i32>),
        FpsInVec(Vec<i32>),
        FpsNotInVec(Vec<i32>),
        FpsLt(i32),
        FpsLte(i32),
        FpsGt(i32),
        FpsGte(i32),
        FpsNot(i32),
        CaptureDeviceMakeEquals(Option<String>),
        CaptureDeviceMakeInVec(Vec<String>),
        CaptureDeviceMakeNotInVec(Vec<String>),
        CaptureDeviceMakeLt(String),
        CaptureDeviceMakeLte(String),
        CaptureDeviceMakeGt(String),
        CaptureDeviceMakeGte(String),
        CaptureDeviceMakeContains(String),
        CaptureDeviceMakeStartsWith(String),
        CaptureDeviceMakeEndsWith(String),
        CaptureDeviceMakeNot(String),
        CaptureDeviceModelEquals(Option<String>),
        CaptureDeviceModelInVec(Vec<String>),
        CaptureDeviceModelNotInVec(Vec<String>),
        CaptureDeviceModelLt(String),
        CaptureDeviceModelLte(String),
        CaptureDeviceModelGt(String),
        CaptureDeviceModelGte(String),
        CaptureDeviceModelContains(String),
        CaptureDeviceModelStartsWith(String),
        CaptureDeviceModelEndsWith(String),
        CaptureDeviceModelNot(String),
        CaptureDeviceSoftwareEquals(Option<String>),
        CaptureDeviceSoftwareInVec(Vec<String>),
        CaptureDeviceSoftwareNotInVec(Vec<String>),
        CaptureDeviceSoftwareLt(String),
        CaptureDeviceSoftwareLte(String),
        CaptureDeviceSoftwareGt(String),
        CaptureDeviceSoftwareGte(String),
        CaptureDeviceSoftwareContains(String),
        CaptureDeviceSoftwareStartsWith(String),
        CaptureDeviceSoftwareEndsWith(String),
        CaptureDeviceSoftwareNot(String),
        DurationSecondsEquals(Option<i32>),
        DurationSecondsInVec(Vec<i32>),
        DurationSecondsNotInVec(Vec<i32>),
        DurationSecondsLt(i32),
        DurationSecondsLte(i32),
        DurationSecondsGt(i32),
        DurationSecondsGte(i32),
        DurationSecondsNot(i32),
        CodecsEquals(Option<String>),
        CodecsInVec(Vec<String>),
        CodecsNotInVec(Vec<String>),
        CodecsLt(String),
        CodecsLte(String),
        CodecsGt(String),
        CodecsGte(String),
        CodecsContains(String),
        CodecsStartsWith(String),
        CodecsEndsWith(String),
        CodecsNot(String),
        StreamsEquals(Option<i32>),
        StreamsInVec(Vec<i32>),
        StreamsNotInVec(Vec<i32>),
        StreamsLt(i32),
        StreamsLte(i32),
        StreamsGt(i32),
        StreamsGte(i32),
        StreamsNot(i32),
        FilesIs(Vec<super::file::WhereParam>),
        FilesIsNot(Vec<super::file::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelWidthEquals(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::PixelWidthInVec(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PixelWidthNotInVec(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PixelWidthLt(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelWidthLte(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelWidthGt(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelWidthGte(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelWidthNot(value) => (
                    "pixel_width".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelHeightEquals(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::PixelHeightInVec(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PixelHeightNotInVec(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PixelHeightLt(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelHeightLte(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelHeightGt(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelHeightGte(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PixelHeightNot(value) => (
                    "pixel_height".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::LongitudeEquals(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| {
                                PrismaValue::Float(
                                    bigdecimal::BigDecimal::from_f64(value)
                                        .unwrap()
                                        .normalized(),
                                )
                                .into()
                            })
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::LongitudeInVec(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| {
                                    PrismaValue::Float(
                                        bigdecimal::BigDecimal::from_f64(v).unwrap().normalized(),
                                    )
                                    .into()
                                })
                                .collect(),
                        ),
                    )]),
                ),
                Self::LongitudeNotInVec(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| {
                                    PrismaValue::Float(
                                        bigdecimal::BigDecimal::from_f64(v).unwrap().normalized(),
                                    )
                                    .into()
                                })
                                .collect(),
                        ),
                    )]),
                ),
                Self::LongitudeLt(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LongitudeLte(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LongitudeGt(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LongitudeGte(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LongitudeNot(value) => (
                    "longitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LatitudeEquals(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| {
                                PrismaValue::Float(
                                    bigdecimal::BigDecimal::from_f64(value)
                                        .unwrap()
                                        .normalized(),
                                )
                                .into()
                            })
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::LatitudeInVec(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| {
                                    PrismaValue::Float(
                                        bigdecimal::BigDecimal::from_f64(v).unwrap().normalized(),
                                    )
                                    .into()
                                })
                                .collect(),
                        ),
                    )]),
                ),
                Self::LatitudeNotInVec(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| {
                                    PrismaValue::Float(
                                        bigdecimal::BigDecimal::from_f64(v).unwrap().normalized(),
                                    )
                                    .into()
                                })
                                .collect(),
                        ),
                    )]),
                ),
                Self::LatitudeLt(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LatitudeLte(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LatitudeGt(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LatitudeGte(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::LatitudeNot(value) => (
                    "latitude".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Float(
                            bigdecimal::BigDecimal::from_f64(value)
                                .unwrap()
                                .normalized(),
                        )
                        .into(),
                    )]),
                ),
                Self::FpsEquals(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::FpsInVec(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::FpsNotInVec(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::FpsLt(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FpsLte(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FpsGt(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FpsGte(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FpsNot(value) => (
                    "fps".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeEquals(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::CaptureDeviceMakeInVec(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CaptureDeviceMakeNotInVec(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CaptureDeviceMakeLt(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeLte(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeGt(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeGte(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeContains(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeStartsWith(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeEndsWith(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceMakeNot(value) => (
                    "capture_device_make".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelEquals(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::CaptureDeviceModelInVec(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CaptureDeviceModelNotInVec(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CaptureDeviceModelLt(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelLte(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelGt(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelGte(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelContains(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelStartsWith(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelEndsWith(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceModelNot(value) => (
                    "capture_device_model".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareEquals(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::CaptureDeviceSoftwareInVec(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CaptureDeviceSoftwareNotInVec(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CaptureDeviceSoftwareLt(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareLte(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareGt(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareGte(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareContains(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareStartsWith(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareEndsWith(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CaptureDeviceSoftwareNot(value) => (
                    "capture_device_software".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::DurationSecondsEquals(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::DurationSecondsInVec(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DurationSecondsNotInVec(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DurationSecondsLt(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DurationSecondsLte(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DurationSecondsGt(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DurationSecondsGte(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DurationSecondsNot(value) => (
                    "duration_seconds".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CodecsEquals(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::CodecsInVec(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CodecsNotInVec(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CodecsLt(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsLte(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsGt(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsGte(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsContains(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsStartsWith(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsEndsWith(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::CodecsNot(value) => (
                    "codecs".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::StreamsEquals(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::StreamsInVec(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::StreamsNotInVec(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::StreamsLt(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StreamsLte(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StreamsGt(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StreamsGte(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StreamsNot(value) => (
                    "streams".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FilesIs(value) => (
                    "files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::FilesIsNot(value) => (
                    "files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData", _outputs()))
                .await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData", _outputs()))
                .await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData", _outputs()))
                .await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData", _outputs()))
                .await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx
                .execute(args.to_operation("MediaData", _outputs()))
                .await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData", _outputs()))
                .await
        }
        pub fn create(mut self, mut params: Vec<SetParam>) -> Self {
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx
                .execute(args.to_operation("MediaData", _outputs()))
                .await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("MediaData"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, mut params: Vec<SetParam>) -> Create {
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
pub mod tag {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: i32) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod pub_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::PubIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::PubId(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::PubId(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PubIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::PubIdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::PubIdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::PubIdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::PubIdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::PubIdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::PubIdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::PubIdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::PubIdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::PubIdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetPubId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<String>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<String>) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(Option<String>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod total_files {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::TotalFilesEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TotalFiles(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTotalFiles(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTotalFiles(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTotalFiles(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTotalFiles(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TotalFilesInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TotalFilesNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::TotalFilesLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::TotalFilesLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::TotalFilesGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::TotalFilesGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::TotalFilesNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTotalFiles(value.0)
            }
        }
    }
    pub mod redundancy_goal {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::RedundancyGoalEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::RedundancyGoal(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementRedundancyGoal(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementRedundancyGoal(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyRedundancyGoal(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideRedundancyGoal(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RedundancyGoalInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::RedundancyGoalNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::RedundancyGoalLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::RedundancyGoalLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::RedundancyGoalGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::RedundancyGoalGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::RedundancyGoalNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetRedundancyGoal(value.0)
            }
        }
    }
    pub mod date_created {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateCreated(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateCreated(value.0)
            }
        }
    }
    pub mod date_modified {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateModified(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateModifiedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateModifiedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateModified(value.0)
            }
        }
    }
    pub mod tag_files {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn some(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
            WhereParam::TagFilesSome(value)
        }
        pub fn every(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
            WhereParam::TagFilesEvery(value)
        }
        pub fn none(value: Vec<tag_on_file::WhereParam>) -> WhereParam {
            WhereParam::TagFilesNone(value)
        }
        pub fn fetch(params: Vec<tag_on_file::WhereParam>) -> tag_on_file::FindManyArgs {
            tag_on_file::FindManyArgs::new(params)
        }
        pub fn link<T: From<Link>>(params: Vec<tag_on_file::UniqueWhereParam>) -> T {
            Link(params).into()
        }
        pub fn unlink(params: Vec<tag_on_file::UniqueWhereParam>) -> SetParam {
            SetParam::UnlinkTagFiles(params)
        }
        pub struct Link(Vec<tag_on_file::UniqueWhereParam>);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkTagFiles(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "pub_id",
            "name",
            "total_files",
            "redundancy_goal",
            "date_created",
            "date_modified",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: i32,
        #[serde(rename = "pub_id")]
        pub pub_id: String,
        #[serde(rename = "name")]
        pub name: Option<String>,
        #[serde(rename = "total_files")]
        pub total_files: Option<i32>,
        #[serde(rename = "redundancy_goal")]
        pub redundancy_goal: Option<i32>,
        #[serde(rename = "date_created")]
        pub date_created: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "date_modified")]
        pub date_modified: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "tag_files")]
        tag_files: Option<Vec<super::tag_on_file::Data>>,
    }
    impl Data {
        pub fn tag_files(&self) -> Result<&Vec<super::tag_on_file::Data>, String> {
            match self.tag_files.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access tag_files but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        TagFiles(super::tag_on_file::FindManyArgs),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::TagFiles(args) => {
                    let FindManySelectionArgs {
                        mut nested_selections,
                        arguments,
                    } = args.into();
                    nested_selections.extend(super::tag_on_file::_outputs());
                    let mut builder = Selection::builder("tag_files");
                    builder
                        .nested_selections(nested_selections)
                        .set_arguments(arguments);
                    builder.build()
                }
            }
        }
    }
    impl From<super::tag_on_file::FindManyArgs> for WithParam {
        fn from(args: super::tag_on_file::FindManyArgs) -> Self {
            Self::TagFiles(args)
        }
    }
    pub enum SetParam {
        SetId(i32),
        IncrementId(i32),
        DecrementId(i32),
        MultiplyId(i32),
        DivideId(i32),
        SetPubId(String),
        SetName(Option<String>),
        SetTotalFiles(Option<i32>),
        IncrementTotalFiles(i32),
        DecrementTotalFiles(i32),
        MultiplyTotalFiles(i32),
        DivideTotalFiles(i32),
        SetRedundancyGoal(Option<i32>),
        IncrementRedundancyGoal(i32),
        DecrementRedundancyGoal(i32),
        MultiplyRedundancyGoal(i32),
        DivideRedundancyGoal(i32),
        SetDateCreated(chrono::DateTime<chrono::FixedOffset>),
        SetDateModified(chrono::DateTime<chrono::FixedOffset>),
        LinkTagFiles(Vec<super::tag_on_file::UniqueWhereParam>),
        UnlinkTagFiles(Vec<super::tag_on_file::UniqueWhereParam>),
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::Int(value as i64).into()),
                SetParam::IncrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideId(value) => (
                    "id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetPubId(value) => {
                    ("pub_id".to_string(), PrismaValue::String(value).into())
                }
                SetParam::SetName(value) => (
                    "name".to_string(),
                    value
                        .map(|value| PrismaValue::String(value).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::SetTotalFiles(value) => (
                    "total_files".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementTotalFiles(value) => (
                    "total_files".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementTotalFiles(value) => (
                    "total_files".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyTotalFiles(value) => (
                    "total_files".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideTotalFiles(value) => (
                    "total_files".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetRedundancyGoal(value) => (
                    "redundancy_goal".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementRedundancyGoal(value) => (
                    "redundancy_goal".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementRedundancyGoal(value) => (
                    "redundancy_goal".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyRedundancyGoal(value) => (
                    "redundancy_goal".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideRedundancyGoal(value) => (
                    "redundancy_goal".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetDateCreated(value) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::SetDateModified(value) => (
                    "date_modified".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::LinkTagFiles(where_params) => (
                    "tag_files".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    where_params
                                        .into_iter()
                                        .map(Into::<super::tag_on_file::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::UnlinkTagFiles(where_params) => (
                    "tag_files".to_string(),
                    QueryValue::Object(
                        vec![(
                            "disconnect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    where_params
                                        .into_iter()
                                        .map(Into::<super::tag_on_file::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        PubId(Direction),
        Name(Direction),
        TotalFiles(Direction),
        RedundancyGoal(Direction),
        DateCreated(Direction),
        DateModified(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::PubId(direction) => (
                    "pub_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Name(direction) => (
                    "name".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::TotalFiles(direction) => (
                    "total_files".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::RedundancyGoal(direction) => (
                    "redundancy_goal".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateCreated(direction) => (
                    "date_created".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateModified(direction) => (
                    "date_modified".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(i32),
        PubId(String),
        Name(String),
        TotalFiles(i32),
        RedundancyGoal(i32),
        DateCreated(chrono::DateTime<chrono::FixedOffset>),
        DateModified(chrono::DateTime<chrono::FixedOffset>),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::Int(cursor as i64).into()),
                Self::PubId(cursor) => ("pub_id".to_string(), PrismaValue::String(cursor).into()),
                Self::Name(cursor) => ("name".to_string(), PrismaValue::String(cursor).into()),
                Self::TotalFiles(cursor) => (
                    "total_files".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::RedundancyGoal(cursor) => (
                    "redundancy_goal".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::DateCreated(cursor) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
                Self::DateModified(cursor) => (
                    "date_modified".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(i32),
        IdInVec(Vec<i32>),
        IdNotInVec(Vec<i32>),
        IdLt(i32),
        IdLte(i32),
        IdGt(i32),
        IdGte(i32),
        IdNot(i32),
        PubIdEquals(String),
        PubIdInVec(Vec<String>),
        PubIdNotInVec(Vec<String>),
        PubIdLt(String),
        PubIdLte(String),
        PubIdGt(String),
        PubIdGte(String),
        PubIdContains(String),
        PubIdStartsWith(String),
        PubIdEndsWith(String),
        PubIdNot(String),
        NameEquals(Option<String>),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameNot(String),
        TotalFilesEquals(Option<i32>),
        TotalFilesInVec(Vec<i32>),
        TotalFilesNotInVec(Vec<i32>),
        TotalFilesLt(i32),
        TotalFilesLte(i32),
        TotalFilesGt(i32),
        TotalFilesGte(i32),
        TotalFilesNot(i32),
        RedundancyGoalEquals(Option<i32>),
        RedundancyGoalInVec(Vec<i32>),
        RedundancyGoalNotInVec(Vec<i32>),
        RedundancyGoalLt(i32),
        RedundancyGoalLte(i32),
        RedundancyGoalGt(i32),
        RedundancyGoalGte(i32),
        RedundancyGoalNot(i32),
        DateCreatedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedLt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedLte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedNot(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateModifiedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateModifiedLt(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedLte(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedGt(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedGte(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedNot(chrono::DateTime<chrono::FixedOffset>),
        TagFilesSome(Vec<super::tag_on_file::WhereParam>),
        TagFilesEvery(Vec<super::tag_on_file::WhereParam>),
        TagFilesNone(Vec<super::tag_on_file::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::PubIdEquals(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdInVec(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PubIdNotInVec(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::PubIdLt(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdLte(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdGt(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdGte(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdContains(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdStartsWith(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdEndsWith(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::PubIdNot(value) => (
                    "pub_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameEquals(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::String(value).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::NameInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameLte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameGt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameGte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameContains(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameStartsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameEndsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameNot(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::TotalFilesEquals(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::TotalFilesInVec(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::TotalFilesNotInVec(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::TotalFilesLt(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TotalFilesLte(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TotalFilesGt(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TotalFilesGte(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TotalFilesNot(value) => (
                    "total_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::RedundancyGoalEquals(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::RedundancyGoalInVec(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::RedundancyGoalNotInVec(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::RedundancyGoalLt(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::RedundancyGoalLte(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::RedundancyGoalGt(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::RedundancyGoalGte(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::RedundancyGoalNot(value) => (
                    "redundancy_goal".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DateCreatedEquals(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedNotInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedLt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedLte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedNot(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedEquals(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedInVec(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateModifiedNotInVec(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateModifiedLt(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedLte(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedGt(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedGte(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedNot(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::TagFilesSome(value) => (
                    "tag_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "some".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagFilesEvery(value) => (
                    "tag_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "every".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagFilesNone(value) => (
                    "tag_files".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "none".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(i32),
        PubIdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
                UniqueWhereParam::PubIdEquals(value) => Self::PubIdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag", _outputs())).await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag", _outputs())).await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("Tag", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag", _outputs())).await
        }
        pub fn create(mut self, pub_id: pub_id::Set, mut params: Vec<SetParam>) -> Self {
            params.push(pub_id.into());
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("Tag", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Tag"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(&self, pub_id: pub_id::Set, mut params: Vec<SetParam>) -> Create {
            params.push(pub_id.into());
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
pub mod tag_on_file {
    use super::*;
    pub mod date_created {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateCreated(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateCreated(value.0)
            }
        }
    }
    pub mod tag_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TagIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TagId(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTagId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTagId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTagId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTagId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TagIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TagIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::TagIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::TagIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::TagIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::TagIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::TagIdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTagId(value.0)
            }
        }
    }
    pub mod tag {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<tag::WhereParam>) -> WhereParam {
            WhereParam::TagIs(value)
        }
        pub fn is_not(value: Vec<tag::WhereParam>) -> WhereParam {
            WhereParam::TagIsNot(value)
        }
        pub fn fetch() -> tag::Args {
            tag::Args::new()
        }
        pub fn link<T: From<Link>>(value: tag::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(tag::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkTag(value.0)
            }
        }
    }
    pub mod file_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::FileIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::FileId(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementFileId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementFileId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyFileId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideFileId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::FileIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::FileIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::FileIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::FileIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::FileIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::FileIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::FileIdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetFileId(value.0)
            }
        }
    }
    pub mod file {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<file::WhereParam>) -> WhereParam {
            WhereParam::FileIs(value)
        }
        pub fn is_not(value: Vec<file::WhereParam>) -> WhereParam {
            WhereParam::FileIsNot(value)
        }
        pub fn fetch() -> file::Args {
            file::Args::new()
        }
        pub fn link<T: From<Link>>(value: file::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub struct Link(file::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkFile(value.0)
            }
        }
    }
    pub fn tag_id_file_id<T: From<UniqueWhereParam>>(tag_id: i32, file_id: i32) -> T {
        UniqueWhereParam::TagIdFileIdEquals(tag_id, file_id).into()
    }
    pub fn _outputs() -> Vec<Selection> {
        ["date_created", "tag_id", "file_id"]
            .into_iter()
            .map(|o| {
                let builder = Selection::builder(o);
                builder.build()
            })
            .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "date_created")]
        pub date_created: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "tag_id")]
        pub tag_id: i32,
        #[serde(rename = "tag")]
        tag: Option<Box<super::tag::Data>>,
        #[serde(rename = "file_id")]
        pub file_id: i32,
        #[serde(rename = "file")]
        file: Option<Box<super::file::Data>>,
    }
    impl Data {
        pub fn tag(&self) -> Result<&super::tag::Data, String> {
            match self.tag.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access tag but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
        pub fn file(&self) -> Result<&super::file::Data, String> {
            match self.file.as_ref() {
                Some(v) => Ok(v),
                None => Err(
                    "Attempted to access file but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        Tag(super::tag::Args),
        File(super::file::Args),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::Tag(args) => {
                    let mut selections = super::tag::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("tag");
                    builder.nested_selections(selections);
                    builder.build()
                }
                Self::File(args) => {
                    let mut selections = super::file::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("file");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    impl From<super::tag::Args> for WithParam {
        fn from(args: super::tag::Args) -> Self {
            Self::Tag(args)
        }
    }
    impl From<super::file::Args> for WithParam {
        fn from(args: super::file::Args) -> Self {
            Self::File(args)
        }
    }
    pub enum SetParam {
        SetDateCreated(chrono::DateTime<chrono::FixedOffset>),
        SetTagId(i32),
        IncrementTagId(i32),
        DecrementTagId(i32),
        MultiplyTagId(i32),
        DivideTagId(i32),
        LinkTag(super::tag::UniqueWhereParam),
        SetFileId(i32),
        IncrementFileId(i32),
        DecrementFileId(i32),
        MultiplyFileId(i32),
        DivideFileId(i32),
        LinkFile(super::file::UniqueWhereParam),
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetDateCreated(value) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::SetTagId(value) => {
                    ("tag_id".to_string(), PrismaValue::Int(value as i64).into())
                }
                SetParam::IncrementTagId(value) => (
                    "tag_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementTagId(value) => (
                    "tag_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyTagId(value) => (
                    "tag_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideTagId(value) => (
                    "tag_id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::LinkTag(where_param) => (
                    "tag".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    vec![where_param]
                                        .into_iter()
                                        .map(Into::<super::tag::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::SetFileId(value) => {
                    ("file_id".to_string(), PrismaValue::Int(value as i64).into())
                }
                SetParam::IncrementFileId(value) => (
                    "file_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementFileId(value) => (
                    "file_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyFileId(value) => (
                    "file_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideFileId(value) => (
                    "file_id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::LinkFile(where_param) => (
                    "file".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    vec![where_param]
                                        .into_iter()
                                        .map(Into::<super::file::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
            }
        }
    }
    pub enum OrderByParam {
        DateCreated(Direction),
        TagId(Direction),
        FileId(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::DateCreated(direction) => (
                    "date_created".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::TagId(direction) => (
                    "tag_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::FileId(direction) => (
                    "file_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        DateCreated(chrono::DateTime<chrono::FixedOffset>),
        TagId(i32),
        FileId(i32),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::DateCreated(cursor) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
                Self::TagId(cursor) => {
                    ("tag_id".to_string(), PrismaValue::Int(cursor as i64).into())
                }
                Self::FileId(cursor) => (
                    "file_id".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        TagIdFileIdEquals(i32, i32),
        DateCreatedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedLt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedLte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedNot(chrono::DateTime<chrono::FixedOffset>),
        TagIdEquals(i32),
        TagIdInVec(Vec<i32>),
        TagIdNotInVec(Vec<i32>),
        TagIdLt(i32),
        TagIdLte(i32),
        TagIdGt(i32),
        TagIdGte(i32),
        TagIdNot(i32),
        TagIs(Vec<super::tag::WhereParam>),
        TagIsNot(Vec<super::tag::WhereParam>),
        FileIdEquals(i32),
        FileIdInVec(Vec<i32>),
        FileIdNotInVec(Vec<i32>),
        FileIdLt(i32),
        FileIdLte(i32),
        FileIdGt(i32),
        FileIdGte(i32),
        FileIdNot(i32),
        FileIs(Vec<super::file::WhereParam>),
        FileIsNot(Vec<super::file::WhereParam>),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::TagIdFileIdEquals(tag_id, file_id) => (
                    "tag_id_file_id".to_string(),
                    SerializedWhereValue::Object(vec![
                        ("tag_id".to_string(), PrismaValue::Int(tag_id as i64).into()),
                        (
                            "file_id".to_string(),
                            PrismaValue::Int(file_id as i64).into(),
                        ),
                    ]),
                ),
                Self::DateCreatedEquals(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedNotInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedLt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedLte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedNot(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::TagIdEquals(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TagIdInVec(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagIdNotInVec(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagIdLt(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TagIdLte(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TagIdGt(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TagIdGte(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TagIdNot(value) => (
                    "tag_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TagIs(value) => (
                    "tag".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::TagIsNot(value) => (
                    "tag".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::FileIdEquals(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FileIdInVec(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::FileIdNotInVec(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::FileIdLt(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FileIdLte(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FileIdGt(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FileIdGte(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FileIdNot(value) => (
                    "file_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::FileIs(value) => (
                    "file".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::FileIsNot(value) => (
                    "file".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        TagIdFileIdEquals(i32, i32),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::TagIdFileIdEquals(tag_id, file_id) => {
                    Self::TagIdFileIdEquals(tag_id, file_id)
                }
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile", _outputs()))
                .await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile", _outputs()))
                .await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile", _outputs()))
                .await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile", _outputs()))
                .await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx
                .execute(args.to_operation("TagOnFile", _outputs()))
                .await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile", _outputs()))
                .await
        }
        pub fn create(
            mut self,
            tag: tag::Link,
            file: file::Link,
            mut params: Vec<SetParam>,
        ) -> Self {
            params.push(tag.into());
            params.push(file.into());
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx
                .execute(args.to_operation("TagOnFile", _outputs()))
                .await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("TagOnFile"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            tag: tag::Link,
            file: file::Link,
            mut params: Vec<SetParam>,
        ) -> Create {
            params.push(tag.into());
            params.push(file.into());
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
pub mod job {
    use super::*;
    pub mod id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
            UniqueWhereParam::IdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Id(direction)
        }
        pub fn cursor(cursor: String) -> Cursor {
            Cursor::Id(cursor)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::IdNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::IdLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::IdLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::IdGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::IdGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::IdContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::IdStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::IdEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::IdNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetId(value.0)
            }
        }
    }
    pub mod name {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: String) -> T {
            Set(value).into()
        }
        pub fn equals(value: String) -> WhereParam {
            WhereParam::NameEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Name(direction)
        }
        pub fn in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameInVec(value)
        }
        pub fn not_in_vec(value: Vec<String>) -> WhereParam {
            WhereParam::NameNotInVec(value)
        }
        pub fn lt(value: String) -> WhereParam {
            WhereParam::NameLt(value)
        }
        pub fn lte(value: String) -> WhereParam {
            WhereParam::NameLte(value)
        }
        pub fn gt(value: String) -> WhereParam {
            WhereParam::NameGt(value)
        }
        pub fn gte(value: String) -> WhereParam {
            WhereParam::NameGte(value)
        }
        pub fn contains(value: String) -> WhereParam {
            WhereParam::NameContains(value)
        }
        pub fn starts_with(value: String) -> WhereParam {
            WhereParam::NameStartsWith(value)
        }
        pub fn ends_with(value: String) -> WhereParam {
            WhereParam::NameEndsWith(value)
        }
        pub fn not(value: String) -> WhereParam {
            WhereParam::NameNot(value)
        }
        pub struct Set(String);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetName(value.0)
            }
        }
    }
    pub mod node_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::NodeIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::NodeId(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementNodeId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementNodeId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyNodeId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideNodeId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::NodeIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::NodeIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::NodeIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::NodeIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::NodeIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::NodeIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::NodeIdNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetNodeId(value.0)
            }
        }
    }
    pub mod action {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::ActionEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Action(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementAction(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementAction(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyAction(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideAction(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::ActionInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::ActionNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::ActionLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::ActionLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::ActionGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::ActionGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::ActionNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetAction(value.0)
            }
        }
    }
    pub mod status {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::StatusEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::Status(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementStatus(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementStatus(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyStatus(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideStatus(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::StatusInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::StatusNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::StatusLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::StatusLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::StatusGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::StatusGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::StatusNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetStatus(value.0)
            }
        }
    }
    pub mod task_count {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::TaskCountEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::TaskCount(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementTaskCount(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementTaskCount(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyTaskCount(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideTaskCount(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TaskCountInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::TaskCountNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::TaskCountLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::TaskCountLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::TaskCountGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::TaskCountGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::TaskCountNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetTaskCount(value.0)
            }
        }
    }
    pub mod completed_task_count {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::CompletedTaskCountEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::CompletedTaskCount(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementCompletedTaskCount(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementCompletedTaskCount(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyCompletedTaskCount(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideCompletedTaskCount(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::CompletedTaskCountInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::CompletedTaskCountNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::CompletedTaskCountLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::CompletedTaskCountLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::CompletedTaskCountGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::CompletedTaskCountGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::CompletedTaskCountNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetCompletedTaskCount(value.0)
            }
        }
    }
    pub mod date_created {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateCreated(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateCreatedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateCreatedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateCreated(value.0)
            }
        }
    }
    pub mod date_modified {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: chrono::DateTime<chrono::FixedOffset>) -> T {
            Set(value).into()
        }
        pub fn equals(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::DateModified(direction)
        }
        pub fn in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateModifiedInVec(value)
        }
        pub fn not_in_vec(value: Vec<chrono::DateTime<chrono::FixedOffset>>) -> WhereParam {
            WhereParam::DateModifiedNotInVec(value)
        }
        pub fn lt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedLt(value)
        }
        pub fn lte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedLte(value)
        }
        pub fn gt(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedGt(value)
        }
        pub fn gte(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedGte(value)
        }
        pub fn not(value: chrono::DateTime<chrono::FixedOffset>) -> WhereParam {
            WhereParam::DateModifiedNot(value)
        }
        pub struct Set(chrono::DateTime<chrono::FixedOffset>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetDateModified(value.0)
            }
        }
    }
    pub mod seconds_elapsed {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: i32) -> T {
            Set(value).into()
        }
        pub fn equals(value: i32) -> WhereParam {
            WhereParam::SecondsElapsedEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::SecondsElapsed(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementSecondsElapsed(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementSecondsElapsed(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplySecondsElapsed(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideSecondsElapsed(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SecondsElapsedInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::SecondsElapsedNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::SecondsElapsedLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::SecondsElapsedLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::SecondsElapsedGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::SecondsElapsedGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::SecondsElapsedNot(value)
        }
        pub struct Set(i32);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetSecondsElapsed(value.0)
            }
        }
    }
    pub mod user {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn is(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIs(value)
        }
        pub fn is_not(value: Vec<user::WhereParam>) -> WhereParam {
            WhereParam::UserIsNot(value)
        }
        pub fn fetch() -> user::Args {
            user::Args::new()
        }
        pub fn link<T: From<Link>>(value: user::UniqueWhereParam) -> T {
            Link(value).into()
        }
        pub fn unlink() -> SetParam {
            SetParam::UnlinkUser
        }
        pub struct Link(user::UniqueWhereParam);
        impl From<Link> for SetParam {
            fn from(value: Link) -> Self {
                Self::LinkUser(value.0)
            }
        }
    }
    pub mod user_id {
        use super::super::*;
        use super::{Cursor, OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
        pub fn set<T: From<Set>>(value: Option<i32>) -> T {
            Set(value).into()
        }
        pub fn equals(value: Option<i32>) -> WhereParam {
            WhereParam::UserIdEquals(value).into()
        }
        pub fn order(direction: Direction) -> OrderByParam {
            OrderByParam::UserId(direction)
        }
        pub fn increment(value: i32) -> SetParam {
            SetParam::IncrementUserId(value)
        }
        pub fn decrement(value: i32) -> SetParam {
            SetParam::DecrementUserId(value)
        }
        pub fn multiply(value: i32) -> SetParam {
            SetParam::MultiplyUserId(value)
        }
        pub fn divide(value: i32) -> SetParam {
            SetParam::DivideUserId(value)
        }
        pub fn in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::UserIdInVec(value)
        }
        pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
            WhereParam::UserIdNotInVec(value)
        }
        pub fn lt(value: i32) -> WhereParam {
            WhereParam::UserIdLt(value)
        }
        pub fn lte(value: i32) -> WhereParam {
            WhereParam::UserIdLte(value)
        }
        pub fn gt(value: i32) -> WhereParam {
            WhereParam::UserIdGt(value)
        }
        pub fn gte(value: i32) -> WhereParam {
            WhereParam::UserIdGte(value)
        }
        pub fn not(value: i32) -> WhereParam {
            WhereParam::UserIdNot(value)
        }
        pub struct Set(Option<i32>);
        impl From<Set> for SetParam {
            fn from(value: Set) -> Self {
                Self::SetUserId(value.0)
            }
        }
    }
    pub fn _outputs() -> Vec<Selection> {
        [
            "id",
            "name",
            "node_id",
            "action",
            "status",
            "task_count",
            "completed_task_count",
            "date_created",
            "date_modified",
            "seconds_elapsed",
            "userId",
        ]
        .into_iter()
        .map(|o| {
            let builder = Selection::builder(o);
            builder.build()
        })
        .collect()
    }
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct Data {
        #[serde(rename = "id")]
        pub id: String,
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "node_id")]
        pub node_id: i32,
        #[serde(rename = "action")]
        pub action: i32,
        #[serde(rename = "status")]
        pub status: i32,
        #[serde(rename = "task_count")]
        pub task_count: i32,
        #[serde(rename = "completed_task_count")]
        pub completed_task_count: i32,
        #[serde(rename = "date_created")]
        pub date_created: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "date_modified")]
        pub date_modified: chrono::DateTime<chrono::FixedOffset>,
        #[serde(rename = "seconds_elapsed")]
        pub seconds_elapsed: i32,
        #[serde(rename = "User")]
        user: Option<Option<Box<super::user::Data>>>,
        #[serde(rename = "userId")]
        pub user_id: Option<i32>,
    }
    impl Data {
        pub fn user(&self) -> Result<Option<&super::user::Data>, String> {
            match self.user.as_ref() {
                Some(v) => Ok(v.as_ref().map(|v| v.as_ref())),
                None => Err(
                    "Attempted to access user but did not fetch it using the .with() syntax"
                        .to_string(),
                ),
            }
        }
    }
    pub enum WithParam {
        User(super::user::Args),
    }
    impl Into<Selection> for WithParam {
        fn into(self) -> Selection {
            match self {
                Self::User(args) => {
                    let mut selections = super::user::_outputs();
                    selections.extend(args.with_params.into_iter().map(Into::<Selection>::into));
                    let mut builder = Selection::builder("User");
                    builder.nested_selections(selections);
                    builder.build()
                }
            }
        }
    }
    impl From<super::user::Args> for WithParam {
        fn from(args: super::user::Args) -> Self {
            Self::User(args)
        }
    }
    pub enum SetParam {
        SetId(String),
        SetName(String),
        SetNodeId(i32),
        IncrementNodeId(i32),
        DecrementNodeId(i32),
        MultiplyNodeId(i32),
        DivideNodeId(i32),
        SetAction(i32),
        IncrementAction(i32),
        DecrementAction(i32),
        MultiplyAction(i32),
        DivideAction(i32),
        SetStatus(i32),
        IncrementStatus(i32),
        DecrementStatus(i32),
        MultiplyStatus(i32),
        DivideStatus(i32),
        SetTaskCount(i32),
        IncrementTaskCount(i32),
        DecrementTaskCount(i32),
        MultiplyTaskCount(i32),
        DivideTaskCount(i32),
        SetCompletedTaskCount(i32),
        IncrementCompletedTaskCount(i32),
        DecrementCompletedTaskCount(i32),
        MultiplyCompletedTaskCount(i32),
        DivideCompletedTaskCount(i32),
        SetDateCreated(chrono::DateTime<chrono::FixedOffset>),
        SetDateModified(chrono::DateTime<chrono::FixedOffset>),
        SetSecondsElapsed(i32),
        IncrementSecondsElapsed(i32),
        DecrementSecondsElapsed(i32),
        MultiplySecondsElapsed(i32),
        DivideSecondsElapsed(i32),
        LinkUser(super::user::UniqueWhereParam),
        UnlinkUser,
        SetUserId(Option<i32>),
        IncrementUserId(i32),
        DecrementUserId(i32),
        MultiplyUserId(i32),
        DivideUserId(i32),
    }
    impl Into<(String, QueryValue)> for SetParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                SetParam::SetId(value) => ("id".to_string(), PrismaValue::String(value).into()),
                SetParam::SetName(value) => ("name".to_string(), PrismaValue::String(value).into()),
                SetParam::SetNodeId(value) => {
                    ("node_id".to_string(), PrismaValue::Int(value as i64).into())
                }
                SetParam::IncrementNodeId(value) => (
                    "node_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementNodeId(value) => (
                    "node_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyNodeId(value) => (
                    "node_id".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideNodeId(value) => (
                    "node_id".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetAction(value) => {
                    ("action".to_string(), PrismaValue::Int(value as i64).into())
                }
                SetParam::IncrementAction(value) => (
                    "action".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementAction(value) => (
                    "action".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyAction(value) => (
                    "action".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideAction(value) => (
                    "action".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetStatus(value) => {
                    ("status".to_string(), PrismaValue::Int(value as i64).into())
                }
                SetParam::IncrementStatus(value) => (
                    "status".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementStatus(value) => (
                    "status".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyStatus(value) => (
                    "status".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideStatus(value) => (
                    "status".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetTaskCount(value) => (
                    "task_count".to_string(),
                    PrismaValue::Int(value as i64).into(),
                ),
                SetParam::IncrementTaskCount(value) => (
                    "task_count".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementTaskCount(value) => (
                    "task_count".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyTaskCount(value) => (
                    "task_count".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideTaskCount(value) => (
                    "task_count".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetCompletedTaskCount(value) => (
                    "completed_task_count".to_string(),
                    PrismaValue::Int(value as i64).into(),
                ),
                SetParam::IncrementCompletedTaskCount(value) => (
                    "completed_task_count".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementCompletedTaskCount(value) => (
                    "completed_task_count".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyCompletedTaskCount(value) => (
                    "completed_task_count".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideCompletedTaskCount(value) => (
                    "completed_task_count".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetDateCreated(value) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::SetDateModified(value) => (
                    "date_modified".to_string(),
                    PrismaValue::DateTime(value).into(),
                ),
                SetParam::SetSecondsElapsed(value) => (
                    "seconds_elapsed".to_string(),
                    PrismaValue::Int(value as i64).into(),
                ),
                SetParam::IncrementSecondsElapsed(value) => (
                    "seconds_elapsed".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementSecondsElapsed(value) => (
                    "seconds_elapsed".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplySecondsElapsed(value) => (
                    "seconds_elapsed".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideSecondsElapsed(value) => (
                    "seconds_elapsed".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::LinkUser(where_param) => (
                    "User".to_string(),
                    QueryValue::Object(
                        vec![(
                            "connect".to_string(),
                            QueryValue::Object(
                                transform_equals(
                                    vec![where_param]
                                        .into_iter()
                                        .map(Into::<super::user::WhereParam>::into)
                                        .map(Into::into),
                                )
                                .into_iter()
                                .collect(),
                            ),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::UnlinkUser => (
                    "User".to_string(),
                    QueryValue::Object(
                        vec![("disconnect".to_string(), QueryValue::Boolean(true))]
                            .into_iter()
                            .collect(),
                    ),
                ),
                SetParam::SetUserId(value) => (
                    "userId".to_string(),
                    value
                        .map(|value| PrismaValue::Int(value as i64).into())
                        .unwrap_or(QueryValue::Null),
                ),
                SetParam::IncrementUserId(value) => (
                    "userId".to_string(),
                    QueryValue::Object(
                        vec![(
                            "increment".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DecrementUserId(value) => (
                    "userId".to_string(),
                    QueryValue::Object(
                        vec![(
                            "decrement".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::MultiplyUserId(value) => (
                    "userId".to_string(),
                    QueryValue::Object(
                        vec![(
                            "multiply".to_string(),
                            PrismaValue::Int(value as i64).into(),
                        )]
                        .into_iter()
                        .collect(),
                    ),
                ),
                SetParam::DivideUserId(value) => (
                    "userId".to_string(),
                    QueryValue::Object(
                        vec![("divide".to_string(), PrismaValue::Int(value as i64).into())]
                            .into_iter()
                            .collect(),
                    ),
                ),
            }
        }
    }
    pub enum OrderByParam {
        Id(Direction),
        Name(Direction),
        NodeId(Direction),
        Action(Direction),
        Status(Direction),
        TaskCount(Direction),
        CompletedTaskCount(Direction),
        DateCreated(Direction),
        DateModified(Direction),
        SecondsElapsed(Direction),
        UserId(Direction),
    }
    impl Into<(String, QueryValue)> for OrderByParam {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(direction) => {
                    ("id".to_string(), QueryValue::String(direction.to_string()))
                }
                Self::Name(direction) => (
                    "name".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::NodeId(direction) => (
                    "node_id".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Action(direction) => (
                    "action".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::Status(direction) => (
                    "status".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::TaskCount(direction) => (
                    "task_count".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::CompletedTaskCount(direction) => (
                    "completed_task_count".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateCreated(direction) => (
                    "date_created".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::DateModified(direction) => (
                    "date_modified".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::SecondsElapsed(direction) => (
                    "seconds_elapsed".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
                Self::UserId(direction) => (
                    "userId".to_string(),
                    QueryValue::String(direction.to_string()),
                ),
            }
        }
    }
    pub enum Cursor {
        Id(String),
        Name(String),
        NodeId(i32),
        Action(i32),
        Status(i32),
        TaskCount(i32),
        CompletedTaskCount(i32),
        DateCreated(chrono::DateTime<chrono::FixedOffset>),
        DateModified(chrono::DateTime<chrono::FixedOffset>),
        SecondsElapsed(i32),
        UserId(i32),
    }
    impl Into<(String, QueryValue)> for Cursor {
        fn into(self) -> (String, QueryValue) {
            match self {
                Self::Id(cursor) => ("id".to_string(), PrismaValue::String(cursor).into()),
                Self::Name(cursor) => ("name".to_string(), PrismaValue::String(cursor).into()),
                Self::NodeId(cursor) => (
                    "node_id".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::Action(cursor) => {
                    ("action".to_string(), PrismaValue::Int(cursor as i64).into())
                }
                Self::Status(cursor) => {
                    ("status".to_string(), PrismaValue::Int(cursor as i64).into())
                }
                Self::TaskCount(cursor) => (
                    "task_count".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::CompletedTaskCount(cursor) => (
                    "completed_task_count".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::DateCreated(cursor) => (
                    "date_created".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
                Self::DateModified(cursor) => (
                    "date_modified".to_string(),
                    PrismaValue::DateTime(cursor).into(),
                ),
                Self::SecondsElapsed(cursor) => (
                    "seconds_elapsed".to_string(),
                    PrismaValue::Int(cursor as i64).into(),
                ),
                Self::UserId(cursor) => {
                    ("userId".to_string(), PrismaValue::Int(cursor as i64).into())
                }
            }
        }
    }
    pub enum WhereParam {
        Not(Vec<WhereParam>),
        Or(Vec<WhereParam>),
        And(Vec<WhereParam>),
        IdEquals(String),
        IdInVec(Vec<String>),
        IdNotInVec(Vec<String>),
        IdLt(String),
        IdLte(String),
        IdGt(String),
        IdGte(String),
        IdContains(String),
        IdStartsWith(String),
        IdEndsWith(String),
        IdNot(String),
        NameEquals(String),
        NameInVec(Vec<String>),
        NameNotInVec(Vec<String>),
        NameLt(String),
        NameLte(String),
        NameGt(String),
        NameGte(String),
        NameContains(String),
        NameStartsWith(String),
        NameEndsWith(String),
        NameNot(String),
        NodeIdEquals(i32),
        NodeIdInVec(Vec<i32>),
        NodeIdNotInVec(Vec<i32>),
        NodeIdLt(i32),
        NodeIdLte(i32),
        NodeIdGt(i32),
        NodeIdGte(i32),
        NodeIdNot(i32),
        ActionEquals(i32),
        ActionInVec(Vec<i32>),
        ActionNotInVec(Vec<i32>),
        ActionLt(i32),
        ActionLte(i32),
        ActionGt(i32),
        ActionGte(i32),
        ActionNot(i32),
        StatusEquals(i32),
        StatusInVec(Vec<i32>),
        StatusNotInVec(Vec<i32>),
        StatusLt(i32),
        StatusLte(i32),
        StatusGt(i32),
        StatusGte(i32),
        StatusNot(i32),
        TaskCountEquals(i32),
        TaskCountInVec(Vec<i32>),
        TaskCountNotInVec(Vec<i32>),
        TaskCountLt(i32),
        TaskCountLte(i32),
        TaskCountGt(i32),
        TaskCountGte(i32),
        TaskCountNot(i32),
        CompletedTaskCountEquals(i32),
        CompletedTaskCountInVec(Vec<i32>),
        CompletedTaskCountNotInVec(Vec<i32>),
        CompletedTaskCountLt(i32),
        CompletedTaskCountLte(i32),
        CompletedTaskCountGt(i32),
        CompletedTaskCountGte(i32),
        CompletedTaskCountNot(i32),
        DateCreatedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateCreatedLt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedLte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGt(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedGte(chrono::DateTime<chrono::FixedOffset>),
        DateCreatedNot(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedEquals(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateModifiedNotInVec(Vec<chrono::DateTime<chrono::FixedOffset>>),
        DateModifiedLt(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedLte(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedGt(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedGte(chrono::DateTime<chrono::FixedOffset>),
        DateModifiedNot(chrono::DateTime<chrono::FixedOffset>),
        SecondsElapsedEquals(i32),
        SecondsElapsedInVec(Vec<i32>),
        SecondsElapsedNotInVec(Vec<i32>),
        SecondsElapsedLt(i32),
        SecondsElapsedLte(i32),
        SecondsElapsedGt(i32),
        SecondsElapsedGte(i32),
        SecondsElapsedNot(i32),
        UserIs(Vec<super::user::WhereParam>),
        UserIsNot(Vec<super::user::WhereParam>),
        UserIdEquals(Option<i32>),
        UserIdInVec(Vec<i32>),
        UserIdNotInVec(Vec<i32>),
        UserIdLt(i32),
        UserIdLte(i32),
        UserIdGt(i32),
        UserIdGte(i32),
        UserIdNot(i32),
    }
    impl Into<SerializedWhere> for WhereParam {
        fn into(self) -> SerializedWhere {
            match self {
                Self::Not(value) => (
                    "NOT".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::Or(value) => (
                    "OR".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::And(value) => (
                    "AND".to_string(),
                    SerializedWhereValue::List(
                        value
                            .into_iter()
                            .map(|v| {
                                QueryValue::Object(
                                    transform_equals(
                                        vec![Into::<SerializedWhere>::into(v)].into_iter(),
                                    )
                                    .into_iter()
                                    .collect(),
                                )
                            })
                            .collect(),
                    ),
                ),
                Self::IdEquals(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdNotInVec(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::IdLt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdLte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdGt(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdGte(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdContains(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdStartsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdEndsWith(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::IdNot(value) => (
                    "id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameEquals(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameNotInVec(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::String(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NameLt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameLte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameGt(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameGte(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameContains(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "contains".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameStartsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "startsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameEndsWith(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "endsWith".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NameNot(value) => (
                    "name".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::String(value).into(),
                    )]),
                ),
                Self::NodeIdEquals(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::NodeIdInVec(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NodeIdNotInVec(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::NodeIdLt(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::NodeIdLte(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::NodeIdGt(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::NodeIdGte(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::NodeIdNot(value) => (
                    "node_id".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::ActionEquals(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::ActionInVec(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActionNotInVec(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::ActionLt(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::ActionLte(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::ActionGt(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::ActionGte(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::ActionNot(value) => (
                    "action".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StatusEquals(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StatusInVec(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::StatusNotInVec(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::StatusLt(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StatusLte(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StatusGt(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StatusGte(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::StatusNot(value) => (
                    "status".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TaskCountEquals(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TaskCountInVec(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::TaskCountNotInVec(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::TaskCountLt(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TaskCountLte(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TaskCountGt(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TaskCountGte(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::TaskCountNot(value) => (
                    "task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CompletedTaskCountEquals(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CompletedTaskCountInVec(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CompletedTaskCountNotInVec(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::CompletedTaskCountLt(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CompletedTaskCountLte(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CompletedTaskCountGt(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CompletedTaskCountGte(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::CompletedTaskCountNot(value) => (
                    "completed_task_count".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::DateCreatedEquals(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedNotInVec(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateCreatedLt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedLte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGt(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedGte(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateCreatedNot(value) => (
                    "date_created".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedEquals(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedInVec(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateModifiedNotInVec(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::DateTime(v).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::DateModifiedLt(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedLte(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedGt(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedGte(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::DateModifiedNot(value) => (
                    "date_modified".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::DateTime(value).into(),
                    )]),
                ),
                Self::SecondsElapsedEquals(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::SecondsElapsedInVec(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::SecondsElapsedNotInVec(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::SecondsElapsedLt(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::SecondsElapsedLte(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::SecondsElapsedGt(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::SecondsElapsedGte(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::SecondsElapsedNot(value) => (
                    "seconds_elapsed".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::UserIs(value) => (
                    "User".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "is".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIsNot(value) => (
                    "User".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "isNot".to_string(),
                        QueryValue::Object(
                            transform_equals(value.into_iter().map(Into::<SerializedWhere>::into))
                                .into_iter()
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIdEquals(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "equals".to_string(),
                        value
                            .map(|value| PrismaValue::Int(value as i64).into())
                            .unwrap_or(QueryValue::Null),
                    )]),
                ),
                Self::UserIdInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "in".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIdNotInVec(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "notIn".to_string(),
                        QueryValue::List(
                            value
                                .into_iter()
                                .map(|v| PrismaValue::Int(v as i64).into())
                                .collect(),
                        ),
                    )]),
                ),
                Self::UserIdLt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::UserIdLte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "lte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::UserIdGt(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gt".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::UserIdGte(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "gte".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
                Self::UserIdNot(value) => (
                    "userId".to_string(),
                    SerializedWhereValue::Object(vec![(
                        "not".to_string(),
                        PrismaValue::Int(value as i64).into(),
                    )]),
                ),
            }
        }
    }
    pub enum UniqueWhereParam {
        IdEquals(String),
    }
    impl From<UniqueWhereParam> for WhereParam {
        fn from(value: UniqueWhereParam) -> Self {
            match value {
                UniqueWhereParam::IdEquals(value) => Self::IdEquals(value),
            }
        }
    }
    impl From<Operator<Self>> for WhereParam {
        fn from(op: Operator<Self>) -> Self {
            match op {
                Operator::Not(value) => Self::Not(value),
                Operator::And(value) => Self::And(value),
                Operator::Or(value) => Self::Or(value),
            }
        }
    }
    pub type FindManyArgs =
        prisma_client_rust::FindManyArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindMany<'a> {
        ctx: QueryContext<'a>,
        args: FindManyArgs,
    }
    impl<'a> FindMany<'a> {
        pub async fn exec(self) -> QueryResult<Vec<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job", _outputs())).await
        }
        pub fn delete(self) -> DeleteMany<'a> {
            let Self { ctx, args } = self;
            DeleteMany {
                ctx,
                args: DeleteManyArgs::new(args.where_params),
            }
        }
        pub fn update(mut self, params: Vec<SetParam>) -> UpdateMany<'a> {
            let Self { ctx, args } = self;
            UpdateMany {
                ctx,
                args: UpdateManyArgs::new(args.where_params, params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type FindFirstArgs =
        prisma_client_rust::FindFirstArgs<WhereParam, WithParam, OrderByParam, Cursor>;
    pub struct FindFirst<'a> {
        ctx: QueryContext<'a>,
        args: FindFirstArgs,
    }
    impl<'a> FindFirst<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn order_by(mut self, param: OrderByParam) -> Self {
            self.args = self.args.order_by(param);
            self
        }
        pub fn skip(mut self, value: i64) -> Self {
            self.args = self.args.skip(value);
            self
        }
        pub fn take(mut self, value: i64) -> Self {
            self.args = self.args.take(value);
            self
        }
        pub fn cursor(mut self, value: impl Into<Cursor>) -> Self {
            self.args = self.args.cursor(value.into());
            self
        }
    }
    pub type Args = prisma_client_rust::Args<WithParam>;
    pub type FindUniqueArgs = prisma_client_rust::FindUniqueArgs<WhereParam, WithParam>;
    pub struct FindUnique<'a> {
        ctx: QueryContext<'a>,
        args: FindUniqueArgs,
    }
    impl<'a> FindUnique<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job", _outputs())).await
        }
        pub fn delete(self) -> Delete<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Delete {
                ctx,
                args: DeleteArgs::new(where_param, with_params),
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Update<'a> {
            let Self { ctx, args } = self;
            let FindUniqueArgs {
                where_param,
                with_params,
            } = args;
            Update {
                ctx,
                args: UpdateArgs::new(where_param, params, with_params),
            }
        }
    }
    pub type CreateArgs = prisma_client_rust::CreateArgs<SetParam, WithParam>;
    pub struct Create<'a> {
        ctx: QueryContext<'a>,
        args: CreateArgs,
    }
    impl<'a> Create<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job", _outputs())).await
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateArgs = prisma_client_rust::UpdateArgs<WhereParam, SetParam, WithParam>;
    pub struct Update<'a> {
        ctx: QueryContext<'a>,
        args: UpdateArgs,
    }
    impl<'a> Update<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("Job", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type UpdateManyArgs = prisma_client_rust::UpdateManyArgs<WhereParam, SetParam>;
    pub struct UpdateMany<'a> {
        ctx: QueryContext<'a>,
        args: UpdateManyArgs,
    }
    impl<'a> UpdateMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub type UpsertArgs = prisma_client_rust::UpsertArgs<WhereParam, SetParam, WithParam>;
    pub struct Upsert<'a> {
        ctx: QueryContext<'a>,
        args: UpsertArgs,
    }
    impl<'a> Upsert<'a> {
        pub async fn exec(self) -> QueryResult<Data> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job", _outputs())).await
        }
        pub fn create(
            mut self,
            id: id::Set,
            name: name::Set,
            node_id: node_id::Set,
            action: action::Set,
            mut params: Vec<SetParam>,
        ) -> Self {
            params.push(id.into());
            params.push(name.into());
            params.push(node_id.into());
            params.push(action.into());
            self.args = self.args.create(params);
            self
        }
        pub fn update(mut self, params: Vec<SetParam>) -> Self {
            self.args = self.args.update(params);
            self
        }
    }
    pub type DeleteArgs = prisma_client_rust::DeleteArgs<WhereParam, WithParam>;
    pub struct Delete<'a> {
        ctx: QueryContext<'a>,
        args: DeleteArgs,
    }
    impl<'a> Delete<'a> {
        pub async fn exec(self) -> QueryResult<Option<Data>> {
            let Self { ctx, args } = self;
            let result = ctx.execute(args.to_operation("Job", _outputs())).await;
            match result {
                Err(QueryError::Execute(CoreError::InterpreterError(
                    InterpreterError::InterpretationError(msg, Some(interpreter_error)),
                ))) => match *interpreter_error {
                    InterpreterError::QueryGraphBuilderError(
                        QueryGraphBuilderError::RecordNotFound(_),
                    ) => Ok(None),
                    res => Err(QueryError::Execute(CoreError::InterpreterError(
                        InterpreterError::InterpretationError(msg, Some(Box::new(res))),
                    ))),
                },
                res => res,
            }
        }
        pub fn with(mut self, params: impl Into<WithParam>) -> Self {
            self.args = self.args.with(params.into());
            self
        }
    }
    pub type DeleteManyArgs = prisma_client_rust::DeleteManyArgs<WhereParam>;
    pub struct DeleteMany<'a> {
        ctx: QueryContext<'a>,
        args: DeleteManyArgs,
    }
    impl<'a> DeleteMany<'a> {
        pub async fn exec(self) -> QueryResult<i64> {
            let Self { ctx, args } = self;
            ctx.execute(args.to_operation("Job"))
                .await
                .map(|res: BatchResult| res.count)
        }
    }
    pub struct Actions<'a> {
        pub client: &'a PrismaClient,
    }
    impl<'a> Actions<'a> {
        pub fn create(
            &self,
            id: id::Set,
            name: name::Set,
            node_id: node_id::Set,
            action: action::Set,
            mut params: Vec<SetParam>,
        ) -> Create {
            params.push(id.into());
            params.push(name.into());
            params.push(node_id.into());
            params.push(action.into());
            Create {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: CreateArgs::new(params),
            }
        }
        pub fn find_unique(&self, param: UniqueWhereParam) -> FindUnique {
            FindUnique {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindUniqueArgs::new(param.into()),
            }
        }
        pub fn find_first(&self, params: Vec<WhereParam>) -> FindFirst {
            FindFirst {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindFirstArgs::new(params),
            }
        }
        pub fn find_many(&self, params: Vec<WhereParam>) -> FindMany {
            FindMany {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: FindManyArgs::new(params),
            }
        }
        pub fn upsert(&self, param: UniqueWhereParam) -> Upsert {
            Upsert {
                ctx: QueryContext::new(&self.client.executor, self.client.query_schema.clone()),
                args: UpsertArgs::new(param.into()),
            }
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum MigrationScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "checksum")]
    Checksum,
    #[serde(rename = "steps_applied")]
    StepsApplied,
    #[serde(rename = "applied_at")]
    AppliedAt,
}
impl ToString for MigrationScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::Id => "id".to_string(),
            Self::Name => "name".to_string(),
            Self::Checksum => "checksum".to_string(),
            Self::StepsApplied => "steps_applied".to_string(),
            Self::AppliedAt => "applied_at".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum UserScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "username")]
    Username,
    #[serde(rename = "index_dir")]
    IndexDir,
    #[serde(rename = "data_dir")]
    DataDir,
    #[serde(rename = "hostname")]
    Hostname,
    #[serde(rename = "platform")]
    Platform,
    #[serde(rename = "date_created")]
    DateCreated,
}
impl ToString for UserScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::Id => "id".to_string(),
            Self::Username => "username".to_string(),
            Self::IndexDir => "index_dir".to_string(),
            Self::DataDir => "data_dir".to_string(),
            Self::Hostname => "hostname".to_string(),
            Self::Platform => "platform".to_string(),
            Self::DateCreated => "date_created".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum FileScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "cas_id")]
    CasId,
    #[serde(rename = "integrity_checksum")]
    IntegrityChecksum,
    #[serde(rename = "kind")]
    Kind,
    #[serde(rename = "size_in_bytes")]
    SizeInBytes,
    #[serde(rename = "key_id")]
    KeyId,
    #[serde(rename = "hidden")]
    Hidden,
    #[serde(rename = "favorite")]
    Favorite,
    #[serde(rename = "important")]
    Important,
    #[serde(rename = "has_thumbnail")]
    HasThumbnail,
    #[serde(rename = "has_thumbstrip")]
    HasThumbstrip,
    #[serde(rename = "has_video_preview")]
    HasVideoPreview,
    #[serde(rename = "ipfs_id")]
    IpfsId,
    #[serde(rename = "comment")]
    Comment,
    #[serde(rename = "date_created")]
    DateCreated,
    #[serde(rename = "date_modified")]
    DateModified,
    #[serde(rename = "date_indexed")]
    DateIndexed,
}
impl ToString for FileScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::Id => "id".to_string(),
            Self::CasId => "cas_id".to_string(),
            Self::IntegrityChecksum => "integrity_checksum".to_string(),
            Self::Kind => "kind".to_string(),
            Self::SizeInBytes => "size_in_bytes".to_string(),
            Self::KeyId => "key_id".to_string(),
            Self::Hidden => "hidden".to_string(),
            Self::Favorite => "favorite".to_string(),
            Self::Important => "important".to_string(),
            Self::HasThumbnail => "has_thumbnail".to_string(),
            Self::HasThumbstrip => "has_thumbstrip".to_string(),
            Self::HasVideoPreview => "has_video_preview".to_string(),
            Self::IpfsId => "ipfs_id".to_string(),
            Self::Comment => "comment".to_string(),
            Self::DateCreated => "date_created".to_string(),
            Self::DateModified => "date_modified".to_string(),
            Self::DateIndexed => "date_indexed".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum MediaDataScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "pixel_width")]
    PixelWidth,
    #[serde(rename = "pixel_height")]
    PixelHeight,
    #[serde(rename = "longitude")]
    Longitude,
    #[serde(rename = "latitude")]
    Latitude,
    #[serde(rename = "fps")]
    Fps,
    #[serde(rename = "capture_device_make")]
    CaptureDeviceMake,
    #[serde(rename = "capture_device_model")]
    CaptureDeviceModel,
    #[serde(rename = "capture_device_software")]
    CaptureDeviceSoftware,
    #[serde(rename = "duration_seconds")]
    DurationSeconds,
    #[serde(rename = "codecs")]
    Codecs,
    #[serde(rename = "streams")]
    Streams,
}
impl ToString for MediaDataScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::Id => "id".to_string(),
            Self::PixelWidth => "pixel_width".to_string(),
            Self::PixelHeight => "pixel_height".to_string(),
            Self::Longitude => "longitude".to_string(),
            Self::Latitude => "latitude".to_string(),
            Self::Fps => "fps".to_string(),
            Self::CaptureDeviceMake => "capture_device_make".to_string(),
            Self::CaptureDeviceModel => "capture_device_model".to_string(),
            Self::CaptureDeviceSoftware => "capture_device_software".to_string(),
            Self::DurationSeconds => "duration_seconds".to_string(),
            Self::Codecs => "codecs".to_string(),
            Self::Streams => "streams".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TagScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "pub_id")]
    PubId,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "total_files")]
    TotalFiles,
    #[serde(rename = "redundancy_goal")]
    RedundancyGoal,
    #[serde(rename = "date_created")]
    DateCreated,
    #[serde(rename = "date_modified")]
    DateModified,
}
impl ToString for TagScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::Id => "id".to_string(),
            Self::PubId => "pub_id".to_string(),
            Self::Name => "name".to_string(),
            Self::TotalFiles => "total_files".to_string(),
            Self::RedundancyGoal => "redundancy_goal".to_string(),
            Self::DateCreated => "date_created".to_string(),
            Self::DateModified => "date_modified".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum TagOnFileScalarFieldEnum {
    #[serde(rename = "date_created")]
    DateCreated,
    #[serde(rename = "tag_id")]
    TagId,
    #[serde(rename = "file_id")]
    FileId,
}
impl ToString for TagOnFileScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::DateCreated => "date_created".to_string(),
            Self::TagId => "tag_id".to_string(),
            Self::FileId => "file_id".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum JobScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "node_id")]
    NodeId,
    #[serde(rename = "action")]
    Action,
    #[serde(rename = "status")]
    Status,
    #[serde(rename = "task_count")]
    TaskCount,
    #[serde(rename = "completed_task_count")]
    CompletedTaskCount,
    #[serde(rename = "date_created")]
    DateCreated,
    #[serde(rename = "date_modified")]
    DateModified,
    #[serde(rename = "seconds_elapsed")]
    SecondsElapsed,
    #[serde(rename = "userId")]
    UserId,
}
impl ToString for JobScalarFieldEnum {
    fn to_string(&self) -> String {
        match self {
            Self::Id => "id".to_string(),
            Self::Name => "name".to_string(),
            Self::NodeId => "node_id".to_string(),
            Self::Action => "action".to_string(),
            Self::Status => "status".to_string(),
            Self::TaskCount => "task_count".to_string(),
            Self::CompletedTaskCount => "completed_task_count".to_string(),
            Self::DateCreated => "date_created".to_string(),
            Self::DateModified => "date_modified".to_string(),
            Self::SecondsElapsed => "seconds_elapsed".to_string(),
            Self::UserId => "userId".to_string(),
        }
    }
}
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
}
impl ToString for SortOrder {
    fn to_string(&self) -> String {
        match self {
            Self::Asc => "asc".to_string(),
            Self::Desc => "desc".to_string(),
        }
    }
}
